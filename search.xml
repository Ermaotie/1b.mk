<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合</title>
      <link href="/2021/02/28/Java%E9%9B%86%E5%90%88/"/>
      <url>/2021/02/28/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<ul><li>集合(Collection)<ul><li>List</li><li>Set (无重复元素</li><li>Map<br>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</li></ul></li></ul><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><p>Hashtable：一种线程安全的Map实现；（一般不会使用）<br>Vector：一种线程安全的List实现；<br>Stack：基于Vector实现的LIFO的栈。<br>还有一小部分接口是遗留接口，也不应该继续使用：</p><p>Enumeration<E>：已被Iterator<E>取代。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; List.of(&quot;apple&quot;,&quot;banana&quot;);</span><br><span class="line">for(Iterator&lt;String&gt; it &#x3D; list.iterator();it.hasNext())&#123;</span><br><span class="line">    String s &#x3D; it.next;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashmap<br>使用hashcode将key直接转换为索引，直接找到所在位置，所在位置为一个List，再在List中找到与key相同的对象返回。<br>因此hashcode()方法不同的key对应尽量不同的hashcode</p><ul><li>作为key的对象必须覆写equals()方法，且相等的key**equals()**必须相等</li><li>作为key的对象必须覆写hashCode()方法</li></ul><p>如果两个对象相等，则两个对象的hashCode()必须相等；<br>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p><p>编写原则：<br>equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。</p><p>另外注意，对于放入HashMap的value对象，没有任何要求。</p><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/01/28/Spring%E5%BC%80%E5%8F%91/"/>
      <url>/2021/01/28/Spring%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring开发"><a href="#Spring开发" class="headerlink" title="Spring开发"></a>Spring开发</h1><p>随着Spring越来越受欢迎，在Spring Framework基础上，又诞生了Spring Boot、Spring Cloud、Spring Data、Spring Security等一系列基于Spring Framework的项目。本章我们只介绍Spring Framework，即最核心的Spring框架。后续章节我们还会涉及Spring Boot、Spring Cloud等其他框架。</p><p><strong>Spring Framework</strong></p><p>Spring Framework主要包括几个模块：</p><ul><li>支持IoC和AOP的容器；</li><li>支持JDBC和ORM的数据访问模块；</li><li>支持声明式事务的模块；</li><li>支持基于Servlet的MVC开发；</li><li>支持基于Reactive的Web开发；</li><li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li></ul><p>我们会依次介绍Spring Framework的主要功能。</p><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p>什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p><p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p><p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p><p>本章我们讨论的IoC容器，主要介绍Spring容器如何对组件进行生命周期管理和配置组装服务。</p><h3 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h3><p>Inversion of Control</p><p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code>BookService</code>自己并不会创建<code>DataSource</code>，而是等待外部通过<code>setDataSource()</code>方法来注入一个<code>DataSource</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.dataSource &#x3D; dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p><ol><li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li><li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li><li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li></ol><p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;HikariDataSource&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;bookService&quot; class&#x3D;&quot;BookService&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;UserService&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p><h4 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h4><p>我们从上面的代码可以看到，依赖注入可以通过<code>set()</code>方法实现。但依赖注入也可以通过构造方法实现。</p><p>很多Java类都具有带参数的构造方法，如果我们把<code>BookService</code>改造为通过构造方法注入，那么实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public BookService(DataSource dataSource) &#123;</span><br><span class="line">        this.dataSource &#x3D; dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p><h4 id="无侵入容器"><a href="#无侵入容器" class="headerlink" title="无侵入容器"></a>无侵入容器</h4><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p><ol><li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li><li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li></ol><h3 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h3><ul><li>每个<code>&lt;bean ...&gt;</code>都有一个<code>id</code>标识，相当于Bean的唯一ID；</li><li>在<code>userService</code>Bean中，通过<code>&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;</code>注入了另一个Bean；</li><li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li></ul><p>Spring容器是通过读取XML文件后使用反射完成的。</p><p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;password&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;maximumPoolSize&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;autoCommit&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br></pre></td></tr></table></figure><p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取Bean:</span><br><span class="line">UserService userService &#x3D; context.getBean(UserService.class);</span><br><span class="line">&#x2F;&#x2F; 正常调用:</span><br><span class="line">User user &#x3D; userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br></pre></td></tr></table></figure><p>完整的<code>main()</code>方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">        UserService userService &#x3D; context.getBean(UserService.class);</span><br><span class="line">        User user &#x3D; userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>我们从创建Spring容器的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br></pre></td></tr></table></figure><p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p><p>获得了<code>ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code>ApplicationContext</code>中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserService userService &#x3D; context.getBean(UserService.class);</span><br></pre></td></tr></table></figure><p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory factory &#x3D; new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));</span><br><span class="line">MailService mailService &#x3D; factory.getBean(MailService.class);</span><br></pre></td></tr></table></figure><p><strong><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于</strong>，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Spring的IoC容器接口是<code>ApplicationContext</code>，并提供了多种实现类；</p><p>通过XML配置文件创建IoC容器时，使用<code>ClassPathXmlApplicationContext</code>；</p><p>持有IoC容器后，通过<code>getBean()</code>方法获取Bean的引用。</p><h3 id="使用Annotation配置"><a href="#使用Annotation配置" class="headerlink" title="使用Annotation配置"></a>使用Annotation配置</h3><p>写好Bean组件，描述出各组件间的配合关系，让容器创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用他们。</p><p> 配置方式：</p><ul><li>xml</li><li>Annotation</li></ul><p>Annotation，Spring可以自动扫描并组装他们。</p><p><strong>@Component</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; User</span><br><span class="line">public class User &#123;</span><br><span class="line">    String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是user，即小写开头的类名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Userservice &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    public UserService(@Autowired User user) &#123;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般把<code>@Autowired</code>写在字段上，通常使用package权限的字段，便于测试。</p><p>最后，编写一个<code>AppConfig</code>的启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        UserService userservice &#x3D; context.getBean(UserService.class);</span><br><span class="line">        &#x2F;&#x2F; 前面的示例未写</span><br><span class="line">        User user &#x3D; UserService.login(&quot;admin&quot;,&quot;passsword&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>main()</code>方法外，<code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure><p>使用的实现类是<code>AnnotationConfigApplicationContext</code>，必须传入一个标注了<code>@Configuration</code>的类名。</p><p>此外，<code>AppConfig</code>还标注了<code>@ComponentScan</code>，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p><p>整个工程结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-annoconfig</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── itranswarp</span><br><span class="line">                    └── learnjava</span><br><span class="line">                        ├── AppConfig.java</span><br><span class="line">                        └── service</span><br><span class="line">                            ├── MailService.java</span><br><span class="line">                            ├── User.java</span><br><span class="line">                            └── UserService.java</span><br></pre></td></tr></table></figure><p>使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：</p><ul><li>每个Bean被标注为<code>@Component</code>并正确使用<code>@Autowired</code>注入；</li><li>配置类被标注为<code>@Configuration</code>和<code>@ComponentScan</code>；</li><li>所有Bean均在指定包以及子包内。</li></ul><p>使用<code>@ComponentScan</code>非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>使用Annotation可以大幅简化配置，每个Bean通过<code>@Component</code>和<code>@Autowired</code>注入；</p><p>必须合理设计包的层次结构，才能发挥<code>@ComponentScan</code>的威力。</p><h3 id="定制Bean"><a href="#定制Bean" class="headerlink" title="定制Bean"></a>定制Bean</h3><p>对于Spring容器来说，当我们把一个Bean标记为<code>@Component</code>后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用<code>getBean(Class)</code>获取到的Bean总是同一个实例。</p><p>还有一种Bean，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code>@Scope</code>注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) &#x2F;&#x2F; @Scope(&quot;prototype&quot;)</span><br><span class="line">public class MailSession &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>Spring默认使用Singleton创建Bean，也可指定Scope为Prototype；</p><p>可将相同类型的Bean注入<code>List</code>；</p><p>可用<code>@Autowired(required=false)</code>允许可选注入；</p><p>可用带<code>@Bean</code>标注的方法创建Bean；</p><p>可使用<code>@PostConstruct</code>和<code>@PreDestroy</code>对Bean进行初始化和清理；</p><p>相同类型的Bean只能有一个指定为<code>@Primary</code>，其他必须用<code>@Quanlifier(&quot;beanName&quot;)</code>指定别名；</p><p>注入时，可通过别名<code>@Quanlifier(&quot;beanName&quot;)</code>指定某个Bean；</p><p>可以定义<code>FactoryBean</code>来使用工厂模式创建Bean。</p><h4 id="注入List"><a href="#注入List" class="headerlink" title="注入List"></a>注入List</h4><p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Validator &#123;</span><br><span class="line">    void validate(String email, String password, String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，分别使用3个<code>Validator</code>对用户参数进行验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EmailValidator implements Validator &#123;</span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        if (!email.matches(&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid email: &quot; + email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class PasswordValidator implements Validator &#123;</span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        if (!password.matches(&quot;^.&#123;6,20&#125;$&quot;)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid password&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class NameValidator implements Validator &#123;</span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        if (name &#x3D;&#x3D; null || name.isBlank() || name.length() &gt; 20) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid name: &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们通过一个<code>Validators</code>作为入口进行验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Validators &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    List&lt;Validator&gt; validators;</span><br><span class="line"></span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        for (var validator : this.validators) &#123;</span><br><span class="line">            validator.validate(email, password, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>Validators</code>被注入了一个<code>List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code>Validator</code>的Bean装配为一个<code>List</code>注入进来，这样一来，我们每新增一个<code>Validator</code>类型，就自动被Spring装配到<code>Validators</code>中了，非常方便。</p><p>因为Spring是通过扫描classpath获取到所有的Bean，而<code>List</code>是有序的，要指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Order(1)</span><br><span class="line">public class EmailValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Order(2)</span><br><span class="line">public class PasswordValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Order(3)</span><br><span class="line">public class NameValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选注入"><a href="#可选注入" class="headerlink" title="可选注入"></a>可选注入</h4><p>默认情况下，当我们标记了一个<code>@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常。</p><p>可以给<code>@Autowired</code>增加一个<code>required = false</code>的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数告诉Spring容器，如果找到一个类型为<code>ZoneId</code>的Bean，就注入，如果找不到，就忽略。</p><p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p><h4 id="创建第三方Bean"><a href="#创建第三方Bean" class="headerlink" title="创建第三方Bean"></a>创建第三方Bean</h4><p>如果一个Bean不在我们自己的package管理之内，例如<code>ZoneId</code>，如何创建它？</p><p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个Bean:</span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring对标记为<code>@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p><h4 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h4><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个<code>init()</code>方法进行初始化，定义一个<code>shutdown()</code>方法进行清理，然后，引入JSR-250定义的Annotation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.annotation&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.annotation-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;Init mail service with zoneId &#x3D; &quot; + this.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        System.out.println(&quot;Shutdown mail service&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring容器会对上述Bean做如下初始化流程：</p><ul><li>调用构造方法创建<code>MailService</code>实例；</li><li>根据<code>@Autowired</code>进行注入；</li><li>调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li></ul><p>而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</p><p>Spring只根据Annotation查找<em>无参数</em>方法，对方法名不作要求。</p><h4 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h4><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code>DataSource</code>实例。</p><p>如果我们在<code>@Configuration</code>类中创建了多个同类型的Bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneOfUTC8() &#123;</span><br><span class="line">        return ZoneId.of(&quot;UTC+08:00&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring会报<code>NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。</p><p>这个时候，需要给每个Bean添加不同的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean(&quot;z&quot;)</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;utc8&quot;)</span><br><span class="line">    ZoneId createZoneOfUTC8() &#123;</span><br><span class="line">        return ZoneId.of(&quot;UTC+08:00&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用<code>@Bean(&quot;name&quot;)</code>指定别名，也可以用<code>@Bean</code>+<code>@Qualifier(&quot;name&quot;)</code>指定别名。</p><p>存在多个同类型的Bean时，注入<code>ZoneId</code>又会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException: No qualifying bean of type &#39;java.time.ZoneId&#39; available: expected single matching bean but found 2</span><br></pre></td></tr></table></figure><p>意思是期待找到唯一的<code>ZoneId</code>类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    @Qualifier(&quot;z&quot;) &#x2F;&#x2F; 指定注入名称为&quot;z&quot;的ZoneId</span><br><span class="line">    ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方法是把其中某个Bean指定为<code>@Primary</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary &#x2F;&#x2F; 指定为主要Bean</span><br><span class="line">    @Qualifier(&quot;z&quot;)</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;utc8&quot;)</span><br><span class="line">    ZoneId createZoneOfUTC8() &#123;</span><br><span class="line">        return ZoneId.of(&quot;UTC+08:00&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code>@Primary</code>的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为<code>@Primary</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    DataSource createMasterDataSource() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;slave&quot;)</span><br><span class="line">    DataSource createSlaveDataSource() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p><h4 id="使用FactoryBean"><a href="#使用FactoryBean" class="headerlink" title="使用FactoryBean"></a>使用FactoryBean</h4><p>我们在设计模式的<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319170474017">工厂方法</a>中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p><p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ZoneIdFactoryBean implements FactoryBean&lt;ZoneId&gt; &#123;</span><br><span class="line"></span><br><span class="line">    String zone &#x3D; &quot;Z&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ZoneId getObject() throws Exception &#123;</span><br><span class="line">        return ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p><h3 id="使用Resource"><a href="#使用Resource" class="headerlink" title="使用Resource"></a>使用Resource</h3><p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p><p>例如，AppService需要读取<code>logo.txt</code>这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p><p>Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AppService &#123;</span><br><span class="line">    @Value(&quot;classpath:&#x2F;logo.txt&quot;)</span><br><span class="line">    private Resource resource;</span><br><span class="line"></span><br><span class="line">    private String logo;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() throws IOException &#123;</span><br><span class="line">        try (var reader &#x3D; new BufferedReader(</span><br><span class="line">                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            this.logo &#x3D; reader.lines().collect(Collectors.joining(&quot;\n&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入<code>Resource</code>最常用的方式是通过classpath，即类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p><p>也可以直接指定文件的路径，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;file:&#x2F;path&#x2F;to&#x2F;logo.txt&quot;)</span><br><span class="line">private Resource resource;</span><br></pre></td></tr></table></figure><p>但使用classpath是最简单的方式。上述工程结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-resource</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               └── AppService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── logo.txt</span><br></pre></td></tr></table></figure><p>使用Maven的标准目录结构，所有资源文件放入<code>src/main/resources</code>即可。</p><p>示例： <code>app.properties</code></p><h3 id="注入配置"><a href="#注入配置" class="headerlink" title="注入配置"></a>注入配置</h3><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p><p>例如，<code>MailService</code>根据配置的<code>app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的<code>Resource</code>来读取位于classpath下的一个<code>app.properties</code>文件。但是，这样仍然比较繁琐。</p><p>Spring容器还提供了一个更简单的<code>@PropertySource</code>来自动读取配置文件。我们只需要在<code>@Configuration</code>配置类上再添加一个注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@PropertySource(&quot;app.properties&quot;) &#x2F;&#x2F; 表示读取classpath的app.properties</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        return ZoneId.of(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring容器看到<code>@PropertySource(&quot;app.properties&quot;)</code>注解后，自动读取这个配置文件，然后，我们使用<code>@Value</code>正常注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span><br><span class="line">String zoneId;</span><br></pre></td></tr></table></figure><p>注意注入的字符串语法，它的格式如下：</p><ul><li><code>&quot;$&#123;app.zone&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，如果key不存在，启动将报错；</li><li><code>&quot;$&#123;app.zone:Z&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，但如果key不存在，就使用默认值<code>Z</code>。</li></ul><p>这样一来，我们就可以根据<code>app.zone</code>的配置来创建<code>ZoneId</code>。</p><p>还可以把注入的注解写到方法参数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">ZoneId createZoneId(@Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId) &#123;</span><br><span class="line">    return ZoneId.of(zoneId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p><p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code>SmtpConfig</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SmtpConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;smtp.host&#125;&quot;)</span><br><span class="line">    private String host;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;smtp.port:25&#125;&quot;)</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    public String getHost() &#123;</span><br><span class="line">        return host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPort() &#123;</span><br><span class="line">        return port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span><br><span class="line">    private String smtpHost;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span><br><span class="line">    private int smtpPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意观察<code>#&#123;&#125;</code>这种注入语法，它和<code>$&#123;key&#125;</code>不同的是，<code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性，即调用<code>getHost()</code>方法。一个Class名为<code>SmtpConfig</code>的Bean，它在Spring容器中的默认名称就是<code>smtpConfig</code>，除非用<code>@Qualifier</code>指定了名称。</p><p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code>#&#123;bean.property&#125;</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果<code>SmtpConfig</code>决定从数据库中读取相关配置项，那么<code>MailService</code>注入的<code>@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</code>仍然可以不修改正常运行。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>Spring容器可以通过<code>@PropertySource</code>自动读取配置，并以<code>@Value(&quot;$&#123;key&#125;&quot;)</code>的形式注入；</p><p>可以通过<code>$&#123;key:defaultValue&#125;</code>指定默认值；</p><p>以<code>#&#123;bean.property&#125;</code>形式注入时，Spring容器自动把指定Bean的指定属性值注入。</p><h3 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h3><p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p><p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p><ul><li>native</li><li>test</li><li>production</li></ul><p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建。例如，以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;!test&quot;)</span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        return ZoneId.systemDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;test&quot;)</span><br><span class="line">    ZoneId creat eZoneIdForTest() &#123;</span><br><span class="line">        return ZoneId.of(&quot;America&#x2F;New_York&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的Profile设置为<code>test</code>，则Spring容器会调用<code>createZoneIdForTest()</code>创建<code>ZoneId</code>，否则，调用<code>createZoneId()</code>创建<code>ZoneId</code>。注意到<code>@Profile(&quot;!test&quot;)</code>表示非test环境。</p><p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p><p>实际上，Spring允许指定多个Profile，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active&#x3D;test,master</span><br></pre></td></tr></table></figure><p>可以表示<code>test</code>环境，并使用<code>master</code>分支代码。</p><p>要满足多个Profile条件，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;) &#x2F;&#x2F; 同时满足test和master</span><br><span class="line">ZoneId createZoneId() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Conditional"><a href="#使用Conditional" class="headerlink" title="使用Conditional"></a>使用Conditional</h4><p>除了根据<code>@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code>@Conditional</code>决定是否创建某个Bean。</p><p>例如，我们对<code>SmtpMailService</code>添加如下注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Conditional(OnSmtpEnvCondition.class)</span><br><span class="line">public class SmtpMailService implements MailService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的意思是，如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。<code>OnSmtpEnvCondition</code>的条件是什么呢？我们看一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class OnSmtpEnvCondition implements Condition &#123;</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        return &quot;true&quot;.equalsIgnoreCase(System.getenv(&quot;smtp&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>Spring允许通过<code>@Profile</code>配置不同的Bean；</p><p>Spring还提供了<code>@Conditional</code>来进行条件装配，Spring Boot在此基础上进一步提供了基于配置、Class、Bean等条件进行装配。</p><h2 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h2><p>AOP是Aspect Oriented Programming，即面向切面编程。</p><p>那什么是AOP？</p><p>我们先回顾一下OOP：Object Oriented Programming，OOP作为面向对象编程的模式，获得了巨大的成功，OOP的主要功能是数据封装、继承和多态。</p><p>而AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。</p><p>要理解AOP的概念，我们先用OOP举例，比如一个业务组件<code>BookService</code>，它有几个业务方法：</p><ul><li>createBook：添加新的Book；</li><li>updateBook：修改Book；</li><li>deleteBook：删除Book。</li></ul><p>对每个业务方法，例如，<code>createBook()</code>，除了业务逻辑，还需要安全检查、日志记录和事务处理，它的代码像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    public void createBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        Transaction tx &#x3D; startTransaction();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 核心业务逻辑</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(&quot;created book: &quot; + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续编写<code>updateBook()</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    public void updateBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        Transaction tx &#x3D; startTransaction();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 核心业务逻辑</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(&quot;updated book: &quot; + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化。</p><p>考察业务模型可以发现，<code>BookService</code>关心的是自身的核心逻辑，但整个系统还要求关注安全检查、日志、事务等功能，这些功能实际上“横跨”多个业务方法，为了实现这些功能，不得不在每个业务方法上重复编写代码。</p><p>一种可行的方式是使用<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">Proxy模式</a>，将某个功能，例如，权限检查，放入Proxy中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SecurityCheckBookService implements BookService &#123;</span><br><span class="line">    private final BookService target;</span><br><span class="line"></span><br><span class="line">    public SecurityCheckBookService(BookService target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void securityCheck() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的缺点是比较麻烦，必须先抽取接口，然后，针对每个方法实现Proxy。</p><p>另一种方法是，既然<code>SecurityCheckBookService</code>的代码都是标准的Proxy样板代码，不如把权限检查视作一种切面（Aspect），把日志、事务也视为切面，然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p><p>如果我们以AOP的视角来编写上述业务，可以依次实现：</p><ol><li>核心逻辑，即BookService；</li><li>切面逻辑，即：</li><li>权限检查的Aspect；</li><li>日志的Aspect；</li><li>事务的Aspect。</li></ol><p>然后，以某种方式，让框架来把上述3个Aspect以Proxy的方式“织入”到<code>BookService</code>中，这样一来，就不必编写复杂而冗长的Proxy模式。</p><h4 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h4><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p><p>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p><p>需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。</p><h3 id="装配AOP"><a href="#装配AOP" class="headerlink" title="装配AOP"></a>装配AOP</h3><p>在AOP编程中，我们经常会遇到下面的概念：</p><ul><li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li><li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li><li>Pointcut：切入点，即一组连接点的集合；</li><li>Advice：增强，指特定连接点上执行的动作；</li><li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li><li>Weaving：织入，指将切面整合到程序的执行流程中；</li><li>Interceptor：拦截器，是一种实现增强的方式；</li><li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li><li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li></ul><p>看完上述术语，是不是感觉对AOP有了进一步的困惑？其实，我们不用关心AOP创造的“术语”，只需要理解AOP本质上只是一种代理模式的实现方式，在Spring的容器中实现AOP特别方便。</p><p>我们以<code>UserService</code>和<code>MailService</code>为例，这两个属于核心业务逻辑，现在，我们准备给<code>UserService</code>的每个业务方法执行前添加日志，给<code>MailService</code>的每个业务方法执行前后添加日志，在Spring中，需要以下步骤：</p><p>首先，我们通过Maven引入Spring对AOP的支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便，因为它的定义比较简单。</p><p>然后，我们定义一个<code>LoggingAspect</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line">    &#x2F;&#x2F; 在执行UserService的每个方法前执行:</span><br><span class="line">    @Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span><br><span class="line">    public void doAccessCheck() &#123;</span><br><span class="line">        System.err.println(&quot;[Before] do access check...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在执行MailService的每个方法前后执行:</span><br><span class="line">    @Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span><br><span class="line">    public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        System.err.println(&quot;[Around] start &quot; + pjp.getSignature());</span><br><span class="line">        Object retVal &#x3D; pjp.proceed();</span><br><span class="line">        System.err.println(&quot;[Around] done &quot; + pjp.getSignature());</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>doAccessCheck()</code>方法，我们定义了一个<code>@Before</code>注解，后面的字符串是告诉AspectJ应该在何处执行该方法，这里写的意思是：执行<code>UserService</code>的每个<code>public</code>方法前执行<code>doAccessCheck()</code>代码。</p><p>再观察<code>doLogging()</code>方法，我们定义了一个<code>@Around</code>注解，它和<code>@Before</code>不同，<code>@Around</code>可以决定是否执行目标方法，因此，我们在<code>doLogging()</code>内部先打印日志，再调用方法，最后打印日志后返回结果。</p><p>在<code>LoggingAspect</code>类的声明处，除了用<code>@Component</code>表示它本身也是一个Bean外，我们再加上<code>@Aspect</code>注解，表示它的<code>@Before</code>标注的方法需要注入到<code>UserService</code>的每个<code>public</code>方法执行前，<code>@Around</code>标注的方法需要注入到<code>MailService</code>的每个<code>public</code>方法执行前后。</p><p>紧接着，我们需要给<code>@Configuration</code>类加上一个<code>@EnableAspectJAutoProxy</code>注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。执行代码，我们可以看到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">Welcome, test!</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br><span class="line">Hi, Bob! You are logged in at 2020-02-14T23:13:52.167996+08:00[Asia&#x2F;Shanghai]</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br></pre></td></tr></table></figure><p>这说明执行业务逻辑前后，确实执行了我们定义的Aspect（即<code>LoggingAspect</code>的方法）。</p><p>有些童鞋会问，<code>LoggingAspect</code>定义的方法，是如何注入到其他Bean的呢？</p><p>其实AOP的原理非常简单。我们以<code>LoggingAspect.doAccessCheck()</code>为例，要把它注入到<code>UserService</code>的每个<code>public</code>方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public UserServiceAopProxy extends UserService &#123;</span><br><span class="line">    private UserService target;</span><br><span class="line">    private LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    public UserServiceAopProxy(UserService target, LoggingAspect aspect) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        this.aspect &#x3D; aspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User login(String email, String password) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先执行Aspect的代码:</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        &#x2F;&#x2F; 再执行UserService的逻辑:</span><br><span class="line">        return target.login(email, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User register(String email, String password, String name) &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        return target.register(email, password, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的<code>UserService</code>（原始的<code>UserService</code>实例作为内部变量隐藏在<code>UserServiceAopProxy</code>中）。如果我们打印从Spring容器获取的<code>UserService</code>实例类型，它类似<code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p><p> Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p><p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p><ol><li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li><li>标记<code>@Component</code>和<code>@Aspect</code>；</li><li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li></ol><p>至于AspectJ的注入语法则比较复杂，请参考<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">Spring文档</a>。</p><p>Spring也提供其他方法来装配AOP，但都没有使用AspectJ注解的方式来得简洁明了，所以我们不再作介绍。</p><h4 id="拦截器类型"><a href="#拦截器类型" class="headerlink" title="拦截器类型"></a>拦截器类型</h4><p>顾名思义，拦截器有以下类型：</p><ul><li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li><li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li><li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li><li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li><li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li></ul><h3 id="注解装配AOP"><a href="#注解装配AOP" class="headerlink" title="注解装配AOP"></a>注解装配AOP</h3><p>上一节我们讲解了使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code>语法来定义应该如何装配AOP。</p><p>在实际项目中，这种写法其实很少使用。假设你写了一个<code>SecurityAspect</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class SecurityAspect &#123;</span><br><span class="line">    @Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        if (SecurityContext.getCurrentUser() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;check failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个<code>check()</code>方法拦截。</p><p>还有的童鞋喜欢用方法名前缀进行拦截：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;execution(public * update*(..))&quot;)</span><br><span class="line">public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F; 对update开头的方法切换数据源:</span><br><span class="line">    String old &#x3D; setCurrentDataSource(&quot;master&quot;);</span><br><span class="line">    Object retVal &#x3D; pjp.proceed();</span><br><span class="line">    restoreCurrentDataSource(old);</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p><p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p><p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的<code>@Transactional</code>就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上<code>@Transactional</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    &#x2F;&#x2F; 有事务:</span><br><span class="line">    @Transactional</span><br><span class="line">    public User createUser(String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 无事务:</span><br><span class="line">    public boolean isValidName(String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 有事务:</span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateUser(User user) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接在class级别注解，表示“所有public方法都被安排了”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Transactional</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@Transactional</code>，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p><p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(METHOD)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface MetricTime &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要被监控的关键方法上标注该注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    &#x2F;&#x2F; 监控register()方法性能:</span><br><span class="line">    @MetricTime(&quot;register&quot;)</span><br><span class="line">    public User register(String email, String password, String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义<code>MetricAspect</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MetricAspect &#123;</span><br><span class="line">    @Around(&quot;@annotation(metricTime)&quot;)</span><br><span class="line">    public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable &#123;</span><br><span class="line">        String name &#x3D; metricTime.value();</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            return joinPoint.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            long t &#x3D; System.currentTimeMillis() - start;</span><br><span class="line">            &#x2F;&#x2F; 写入日志或发送至JMX:</span><br><span class="line">            System.err.println(&quot;[Metrics] &quot; + name + &quot;: &quot; + t + &quot;ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法参数类型是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p><p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome, Bob!</span><br><span class="line">[Metrics] register: 16ms</span><br></pre></td></tr></table></figure><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>使用注解实现AOP需要先定义注解，然后使用<code>@Around(&quot;@annotation(name)&quot;)</code>实现装配；</p><p>使用注解既简单，又能明确标识AOP装配，是使用AOP推荐的方式。</p><h3 id="AOP避坑指南"><a href="#AOP避坑指南" class="headerlink" title="AOP避坑指南"></a>AOP避坑指南</h3><p>无论是使用AspectJ语法，还是配合Annotation，使用AOP，实际上就是让Spring自动为我们创建一个Proxy，使得调用方能无感知地调用指定方法，但运行期却动态“织入”了其他逻辑，因此，AOP本质上就是一个<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">代理模式</a>。</p><p>因为Spring使用了CGLIB来实现运行期动态创建Proxy，如果我们没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。</p><p>我们来看一个实际的例子。</p><p>假设我们定义了一个<code>UserService</code>的Bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    &#x2F;&#x2F; 成员变量:</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造方法:</span><br><span class="line">    public UserService() &#123;</span><br><span class="line">        System.out.println(&quot;UserService(): init...&quot;);</span><br><span class="line">        System.out.println(&quot;UserService(): zoneId &#x3D; &quot; + this.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; public方法:</span><br><span class="line">    public ZoneId getZoneId() &#123;</span><br><span class="line">        return zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; public final方法:</span><br><span class="line">    public final ZoneId getFinalZoneId() &#123;</span><br><span class="line">        return zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写个<code>MailService</code>，并注入<code>UserService</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        ZoneId zoneId &#x3D; userService.zoneId;</span><br><span class="line">        String dt &#x3D; ZonedDateTime.now(zoneId).toString();</span><br><span class="line">        return &quot;Hello, it is &quot; + dt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用<code>main()</code>方法测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        MailService mailService &#x3D; context.getBean(MailService.class);</span><br><span class="line">        System.out.println(mailService.sendMail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看输出，一切正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService(): init...</span><br><span class="line">UserService(): zoneId &#x3D; Asia&#x2F;Shanghai</span><br><span class="line">Hello, it is 2020-04-12T10:23:22.917721+08:00[Asia&#x2F;Shanghai]</span><br></pre></td></tr></table></figure><p>下一步，我们给<code>UserService</code>加上AOP支持，就添加一个最简单的<code>LoggingAspect</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line">    @Before(&quot;execution(public * com..*.UserService.*(..))&quot;)</span><br><span class="line">    public void doAccessCheck() &#123;</span><br><span class="line">        System.err.println(&quot;[Before] do access check...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘了在<code>AppConfig</code>上加上<code>@EnableAspectJAutoProxy</code>。再次运行，不出意外的话，会得到一个<code>NullPointerException</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: zone</span><br><span class="line">    at java.base&#x2F;java.util.Objects.requireNonNull(Objects.java:246)</span><br><span class="line">    at java.base&#x2F;java.time.Clock.system(Clock.java:203)</span><br><span class="line">    at java.base&#x2F;java.time.ZonedDateTime.now(ZonedDateTime.java:216)</span><br><span class="line">    at com.itranswarp.learnjava.service.MailService.sendMail(MailService.java:19)</span><br><span class="line">    at com.itranswarp.learnjava.AppConfig.main(AppConfig.java:21)</span><br></pre></td></tr></table></figure><p>仔细跟踪代码，会发现<code>null</code>值出现在<code>MailService.sendMail()</code>内部的这一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        ZoneId zoneId &#x3D; userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); &#x2F;&#x2F; null</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还故意在<code>UserService</code>中特意用<code>final</code>修饰了一下成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>标注的成员变量为<code>null</code>？逗我呢？</p><h4 id="怎么肥四？"><a href="#怎么肥四？" class="headerlink" title="怎么肥四？"></a>怎么肥四？</h4><p>为什么加了AOP就报NPE，去了AOP就一切正常？<code>final</code>字段不执行，难道JVM有问题？为了解答这个诡异的问题，我们需要深入理解Spring使用CGLIB生成Proxy的原理：</p><p>第一步，正常创建一个<code>UserService</code>的原始实例，这是通过反射调用构造方法实现的，它的行为和我们预期的完全一致；</p><p>第二步，通过CGLIB创建一个<code>UserService</code>的子类，并引用了原始实例和<code>LoggingAspect</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public UserService$$EnhancerBySpringCGLIB extends UserService &#123;</span><br><span class="line">    UserService target;</span><br><span class="line">    LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    public UserService$$EnhancerBySpringCGLIB() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZoneId getZoneId() &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        return target.getZoneId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们观察Spring创建的AOP代理，它的类名总是类似<code>UserService$$EnhancerBySpringCGLIB$$1c76af9d</code>（你没看错，Java的类名实际上允许<code>$</code>字符）。为了让调用方获得<code>UserService</code>的引用，它必须继承自<code>UserService</code>。然后，该代理类会覆写所有<code>public</code>和<code>protected</code>方法，并在内部将调用委托给原始的<code>UserService</code>实例。</p><p>这里出现了两个<code>UserService</code>实例：</p><p>一个是我们代码中定义的<em>原始实例</em>，它的成员变量已经按照我们预期的方式被初始化完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserService original &#x3D; new UserService();</span><br></pre></td></tr></table></figure><p>第二个<code>UserService</code>实例实际上类型是<code>UserService$$EnhancerBySpringCGLIB</code>，它引用了原始的<code>UserService</code>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService$$EnhancerBySpringCGLIB proxy &#x3D; new UserService$$EnhancerBySpringCGLIB();</span><br><span class="line">proxy.target &#x3D; original;</span><br><span class="line">proxy.aspect &#x3D; ...</span><br></pre></td></tr></table></figure><p>注意到这种情况仅出现在启用了AOP的情况，此刻，从<code>ApplicationContext</code>中获取的<code>UserService</code>实例是proxy，注入到<code>MailService</code>中的<code>UserService</code>实例也是proxy。</p><p>那么最终的问题来了：proxy实例的成员变量，也就是从<code>UserService</code>继承的<code>zoneId</code>，它的值是<code>null</code>。</p><p>原因在于，<code>UserService</code>成员变量的初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>UserService$$EnhancerBySpringCGLIB</code>中，并未执行。原因是，没必要初始化proxy的成员变量，因为proxy的目的是代理方法。</p><p>实际上，成员变量的初始化是在构造方法中完成的。这是我们看到的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    public UserService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是编译器实际编译的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId;</span><br><span class="line">    public UserService() &#123;</span><br><span class="line">        super(); &#x2F;&#x2F; 构造方法的第一行代码总是调用super()</span><br><span class="line">        zoneId &#x3D; ZoneId.systemDefault(); &#x2F;&#x2F; 继续初始化成员变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，对于Spring通过CGLIB动态创建的<code>UserService$$EnhancerBySpringCGLIB</code>代理类，它的构造方法中，并未调用<code>super()</code>，因此，从父类继承的成员变量，包括<code>final</code>类型的成员变量，统统都没有初始化。</p><p>有的童鞋会问：Java语言规定，任何类的构造方法，第一行必须调用<code>super()</code>，如果没有，编译器会自动加上，怎么Spring的CGLIB就可以搞特殊？</p><p>这是因为自动加<code>super()</code>的功能是Java编译器实现的，它发现你没加，就自动给加上，发现你加错了，就报编译错误。但实际上，如果直接构造字节码，一个类的构造方法中，不一定非要调用<code>super()</code>。Spring使用CGLIB构造的Proxy类，是直接生成字节码，并没有源码-编译-字节码这个步骤，因此：</p><p> Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！</p><p>再考察<code>MailService</code>的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        ZoneId zoneId &#x3D; userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); &#x2F;&#x2F; null</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有启用AOP，注入的是原始的<code>UserService</code>实例，那么一切正常，因为<code>UserService</code>实例的<code>zoneId</code>字段已经被正确初始化了。</p><p>如果启动了AOP，注入的是代理后的<code>UserService$$EnhancerBySpringCGLIB</code>实例，那么问题大了：获取的<code>UserService$$EnhancerBySpringCGLIB</code>实例的<code>zoneId</code>字段，永远为<code>null</code>。</p><p>那么问题来了：启用了AOP，如何修复？</p><p>修复很简单，只需要把直接访问字段的代码，改为通过方法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        &#x2F;&#x2F; 不要直接访问UserService的字段:</span><br><span class="line">        ZoneId zoneId &#x3D; userService.getZoneId();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论注入的<code>UserService</code>是原始实例还是代理实例，<code>getZoneId()</code>都能正常工作，因为代理类会覆写<code>getZoneId()</code>方法，并将其委托给原始实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public UserService$$EnhancerBySpringCGLIB extends UserService &#123;</span><br><span class="line">    UserService target &#x3D; ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public ZoneId getZoneId() &#123;</span><br><span class="line">        return target.getZoneId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我们还给<code>UserService</code>添加了一个<code>public</code>+<code>final</code>的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    ...</span><br><span class="line">    public final ZoneId getFinalZoneId() &#123;</span><br><span class="line">        return zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在<code>MailService</code>中，调用的不是<code>getZoneId()</code>，而是<code>getFinalZoneId()</code>，又会出现<code>NullPointerException</code>，这是因为，代理类无法覆写<code>final</code>方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的<code>zoneId</code>字段，即<code>null</code>。</p><p>实际上，如果我们加上日志，Spring在启动时会打印一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10:43:09.929 [main] DEBUG org.springframework.aop.framework.CglibAopProxy - Final method [public final java.time.ZoneId xxx.UserService.getFinalZoneId()] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance.</span><br></pre></td></tr></table></figure><p>上面的日志大意就是，因为被代理的<code>UserService</code>有一个<code>final</code>方法<code>getFinalZoneId()</code>，这会导致其他Bean如果调用此方法，无法将其代理到真正的原始实例，从而可能发生NPE异常。</p><p>因此，正确使用AOP，我们需要一个避坑指南：</p><ol><li>访问被注入的Bean时，总是调用方法而非直接访问字段；</li><li>编写Bean时，如果可能会被代理，就不要编写<code>public final</code>方法。</li></ol><p>这样才能保证有没有AOP，代码都能正常工作。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>为什么Spring刻意不初始化Proxy继承的字段？</p><p>如果一个Bean不允许任何AOP代理，应该怎么做来“保护”自己在运行期不会被代理？</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>从<a href="https://gitee.com/"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=" alt="img"></a>下载练习：<a href="https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/210.Spring%E5%BC%80%E5%8F%91.1266263217140032/20.%E4%BD%BF%E7%94%A8AOP.1266265125480448/30.AOP%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97.1339039378571298/spring-aop-field.zip?utm_source=blog_lxf">修复启用AOP导致的NPE</a> （推荐使用<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664">IDE练习插件</a>快速下载）</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>由于Spring通过CGLIB实现代理类，我们要避免直接访问Bean的字段，以及由<code>final</code>方法带来的“未代理”问题。</p><p>遇到CglibAopProxy的相关日志，务必要仔细检查，防止因为AOP出现NPE异常。</p><h2 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h2><p>数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。</p><p>我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特定厂商的驱动。</p><p>使用JDBC虽然简单，但代码比较繁琐。Spring为了简化数据库访问，主要做了以下几点工作：</p><ul><li>提供了简化的访问JDBC的模板类，不必手动释放资源；</li><li>提供了一个统一的DAO类以实现Data Access Object模式；</li><li>把<code>SQLException</code>封装为<code>DataAccessException</code>，这个异常是一个<code>RuntimeException</code>，并且让我们能区分SQL异常的原因，例如，<code>DuplicateKeyException</code>表示违反了一个唯一约束；</li><li>能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。</li></ul><p>本章我们将详细讲解在Spring中访问数据库的最佳实践。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/01/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/01/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<hr><p>title: White-Jotter</p><p>date: 2021-1-21 </p><p>tags:</p><p>-–</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>即 Design Pattern。为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p><p>设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类，我们后续会一一讲解。</p><p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。</p><h2 id="创新型模式"><a href="#创新型模式" class="headerlink" title="创新型模式"></a>创新型模式</h2><p>核心思想为将对象创建与使用分离。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><em>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</em></p><p>工厂方法即Factory Method，是一种对象创建型模式。</p><p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│   Product   │      │   Factory   │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br><span class="line">       ▲                    ▲</span><br><span class="line">       │                    │</span><br><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure><p>解耦思想：</p><p>用的管用，做的管做，互不影响</p><p>实现：</p><p>例子：</p><p>练习</p><p>使用静态工厂方法实现一个类似<code>20200202</code>的整数转换为<code>LocalDate</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class LocalDateFactory &#123;</span><br><span class="line">    public static LocalDate fromInt(int yyyyMMdd) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>首先是抽象类接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package 设计模式.工厂方法;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public interface LDFactory &#123;</span><br><span class="line">    LocalDate fromInt(int yyyyMMdd);</span><br><span class="line">    &#x2F;&#x2F; 静态方法调用</span><br><span class="line">    static LDFactoryImpl getFactory() &#123;</span><br><span class="line">        return new LDFactoryImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继承抽象类接口的实体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package 设计模式.工厂方法;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class LDFactoryImpl implements LDFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public LocalDate fromInt(int yyyyMMdd) &#123;</span><br><span class="line">    &#x2F;&#x2F; 具体业务实现</span><br><span class="line">        int yyyy &#x3D; yyyyMMdd &#x2F; 10000;</span><br><span class="line">        int mmdd &#x3D; yyyyMMdd % 10000;</span><br><span class="line">        int mm &#x3D; mmdd &#x2F; 100;</span><br><span class="line">        int dd &#x3D; mmdd % 100;</span><br><span class="line">        System.out.println(LocalDate.of(yyyy,mm,dd));</span><br><span class="line">        return LocalDate.of(yyyy,mm,dd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package 设计模式.工厂方法;</span><br><span class="line"></span><br><span class="line">public class client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 类似黑盒测试，实现交给黑盒子，调用时直接调取抽象类</span><br><span class="line">        &#x2F;&#x2F; 使用时不需要更换方法</span><br><span class="line">        LDFactory factory &#x3D; LDFactory.getFactory();</span><br><span class="line">        factory.fromInt(20010626);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上称为<code>静态工厂方法</code></p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><em>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</em>（Abstract Factory）</p><p>本质就是不同静态工厂的选择，</p><ul><li>用户定义接口</li><li>第三方实现接口并实现其中功能</li><li>用户实现第三方的接口，并按定义的方法使用</li></ul><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><em>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</em></p><p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p><p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p><p>我们仍然以Markdown转HTML为例，因为直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># this is a heading</span><br></pre></td></tr></table></figure><p>转换成HTML就很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;this is a heading&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>因此，我们把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p><ul><li>如果以<code>#</code>开头，使用<code>HeadingBuilder</code>转换；</li><li>如果以<code>&gt;</code>开头，使用<code>QuoteBuilder</code>转换；</li><li>如果以<code>---</code>开头，使用<code>HrBuilder</code>转换；</li><li>其余使用<code>ParagraphBuilder</code>转换。</li></ul><p>这个<code>HtmlBuilder</code>写出来如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HtmlBuilder &#123;</span><br><span class="line">    private HeadingBuilder headingBuilder &#x3D; new HeadingBuilder();</span><br><span class="line">    private HrBuilder hrBuilder &#x3D; new HrBuilder();</span><br><span class="line">    private ParagraphBuilder paragraphBuilder &#x3D; new ParagraphBuilder();</span><br><span class="line">    private QuoteBuilder quoteBuilder &#x3D; new QuoteBuilder();</span><br><span class="line"></span><br><span class="line">    public String toHtml(String markdown) &#123;</span><br><span class="line">        StringBuilder buffer &#x3D; new StringBuilder();</span><br><span class="line">        markdown.lines().forEach(line -&gt; &#123;</span><br><span class="line">            if (line.startsWith(&quot;#&quot;)) &#123;</span><br><span class="line">                buffer.append(headingBuilder.buildHeading(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125; else if (line.startsWith(&quot;&gt;&quot;)) &#123;</span><br><span class="line">                buffer.append(quoteBuilder.buildQuote(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125; else if (line.startsWith(&quot;---&quot;)) &#123;</span><br><span class="line">                buffer.append(hrBuilder.buildHr(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                buffer.append(paragraphBuilder.buildParagraph(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意观察上述代码，<code>HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code>XxxBuilder</code>去转换，最后，把所有转换的结果组合起来，返回给客户端。</p><p>这样一来，我们只需要针对每一种类型编写不同的Builder。例如，针对以<code>#</code>开头的行，需要<code>HeadingBuilder</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HeadingBuilder &#123;</span><br><span class="line">    public String buildHeading(String line) &#123;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        while (line.charAt(0) &#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            line &#x3D; line.substring(1);</span><br><span class="line">        &#125;</span><br><span class="line">        return String.format(&quot;&lt;h%d&gt;%s&lt;&#x2F;h%d&gt;&quot;, n, line.strip(), n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：实际解析Markdown是带有状态的，即下一行的语义可能与上一行相关。这里我们简化了语法，把每一行视为可以独立转换。</p><p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><em>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</em></p><ul><li><p>Cloneable  克隆后为Object对象，需要强转</p></li><li><p>自己定义 copy()</p><p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p></li></ul><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p><em>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</em></p><p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p><p>因为这个类只有一个实例，因此，自然不能让调用方使用<code>new Xyz()</code>来创建实例了。所以，单例的构造方法必须是<code>private</code>，这样就防止了调用方自己创建实例，但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态字段引用唯一实例:</span><br><span class="line">    private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; private构造方法保证外部无法实例化:</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，外部调用方如何获得这个唯一实例？</p><p>答案是提供一个静态方法，直接返回实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态字段引用唯一实例:</span><br><span class="line">    private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过静态方法返回实例:</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; private构造方法保证外部无法实例化:</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接把<code>static</code>变量暴露给外部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态字段引用唯一实例:</span><br><span class="line">    public static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; private构造方法保证外部无法实例化:</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，单例模式的实现方式很简单：</p><ol><li>只有<code>private</code>构造方法，确保外部无法实例化；</li><li>通过<code>private static</code>变量持有唯一实例，保证全局唯一性；</li><li>通过<code>public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li></ol><p>Java标准库有一些类就是单例，例如<code>Runtime</code>这个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime &#x3D; Runtime.getRuntime();</span><br></pre></td></tr></table></figure><p>另一种实现Singleton的方式是利用Java的<code>enum</code>，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum World &#123;</span><br><span class="line">    &#x2F;&#x2F; 唯一枚举:</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    private String name &#x3D; &quot;world&quot;;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code>World</code>类在调用方看来就可以这么用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; World.INSTANCE.getName();</span><br></pre></td></tr></table></figure><p>使用枚举实现Singleton还避免了第一种方式实现Singleton的一个潜在问题：即序列化和反序列化会绕过普通类的<code>private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p><p>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component &#x2F;&#x2F; 表示一个单例组件</span><br><span class="line">public class MyService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p><p>结构型模式有：</p><ul><li>适配器</li><li>桥接</li><li>组合</li><li>装饰器</li><li>外观</li><li>享元</li><li>代理</li></ul><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319245971489">适配器</a></h3><blockquote><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？</p><p>我们举个例子。如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器：</p><p>Adapter模式可以将一个A接口转换为B接口，使得新的对象符合B接口规范。</p><p>编写Adapter实际上就是编写一个实现了B接口，并且内部持有A接口的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public BAdapter implements B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public BAdapter(A a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void b() &#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Adapter内部将B接口的调用“转换”为对A接口的调用。</p><p>只有A、B接口均为<strong>抽象接口</strong>时，才能非常简单地实现Adapter模式。</p><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p><em>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</em></p><p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                   ┌───────┐</span><br><span class="line">                   │  Car  │</span><br><span class="line">                   └───────┘</span><br><span class="line">                       ▲</span><br><span class="line">    ┌──────────────────┼───────────────────┐</span><br><span class="line">    │                  │                   │</span><br><span class="line">┌───────┐          ┌───────┐          ┌───────┐</span><br><span class="line">│BigCar │          │TinyCar│          │BossCar│</span><br><span class="line">└───────┘          └───────┘          └───────┘</span><br><span class="line">    ▲                  ▲                  ▲</span><br><span class="line">    │                  │                  │</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │</span><br><span class="line">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│</span><br><span class="line">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │</span><br><span class="line">      └───────────────┘  └───────────────┘  └───────────────┘</span><br></pre></td></tr></table></figure><p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p><p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p><p>我们来看看桥接模式如何解决上述问题。</p><p>在桥接模式中，首先把<code>Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。</p><p>首先定义抽象类<code>Car</code>，它引用一个<code>Engine</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Car &#123;</span><br><span class="line">    &#x2F;&#x2F; 引用Engine:</span><br><span class="line">    protected Engine engine;</span><br><span class="line"></span><br><span class="line">    public Car(Engine engine) &#123;</span><br><span class="line">        this.engine &#x3D; engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Engine</code>的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Engine &#123;</span><br><span class="line">    void start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着，在一个“修正”的抽象类<code>RefinedCar</code>中定义一些额外操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RefinedCar extends Car &#123;</span><br><span class="line">    public RefinedCar(Engine engine) &#123;</span><br><span class="line">        super(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void drive() &#123;</span><br><span class="line">        this.engine.start();</span><br><span class="line">        System.out.println(&quot;Drive &quot; + getBrand() + &quot; car...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract String getBrand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，最终的不同品牌继承自<code>RefinedCar</code>，例如<code>BossCar</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BossCar extends RefinedCar &#123;</span><br><span class="line">    public BossCar(Engine engine) &#123;</span><br><span class="line">        super(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBrand() &#123;</span><br><span class="line">        return &quot;Boss&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而针对每一种引擎，继承自<code>Engine</code>，例如<code>HybridEngine</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HybridEngine implements Engine &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Start Hybrid Engine...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefinedCar car &#x3D; new BossCar(new HybridEngine());</span><br><span class="line">car.drive();</span><br></pre></td></tr></table></figure><p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code>Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code>RefinedCar</code>派生一个子类，任何<code>RefinedCar</code>的子类都可以和任何一种<code>Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">       ┌───────────┐</span><br><span class="line">       │    Car    │</span><br><span class="line">       └───────────┘</span><br><span class="line">             ▲</span><br><span class="line">             │</span><br><span class="line">       ┌───────────┐       ┌─────────┐</span><br><span class="line">       │RefinedCar │ ─ ─ ─&gt;│ Engine  │</span><br><span class="line">       └───────────┘       └─────────┘</span><br><span class="line">             ▲                  ▲</span><br><span class="line">    ┌────────┼────────┐         │ ┌──────────────┐</span><br><span class="line">    │        │        │         ├─│  FuelEngine  │</span><br><span class="line">┌───────┐┌───────┐┌───────┐     │ └──────────────┘</span><br><span class="line">│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐</span><br><span class="line">└───────┘└───────┘└───────┘     ├─│ElectricEngine│</span><br><span class="line">                                │ └──────────────┘</span><br><span class="line">                                │ ┌──────────────┐</span><br><span class="line">                                └─│ HybridEngine │</span><br><span class="line">                                  └──────────────┘</span><br></pre></td></tr></table></figure><p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p><p>我们来看一个具体的例子。在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p><p>要以树的结构表示XML，我们可以先抽象出节点类型<code>Node</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加一个节点为子节点:</span><br><span class="line">    Node add(Node node);</span><br><span class="line">    &#x2F;&#x2F; 获取子节点:</span><br><span class="line">    List&lt;Node&gt; children();</span><br><span class="line">    &#x2F;&#x2F; 输出为XML:</span><br><span class="line">    String toXml();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个<code>&lt;abc&gt;</code>这样的节点，我们称之为<code>ElementNode</code>，它可以作为容器包含多个子节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ElementNode implements Node &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;Node&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ElementNode(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node add(Node node) &#123;</span><br><span class="line">        list.add(node);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Node&gt; children() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toXml() &#123;</span><br><span class="line">        String start &#x3D; &quot;&lt;&quot; + name + &quot;&gt;\n&quot;;</span><br><span class="line">        String end &#x3D; &quot;&lt;&#x2F;&quot; + name + &quot;&gt;\n&quot;;</span><br><span class="line">        StringJoiner sj &#x3D; new StringJoiner(&quot;&quot;, start, end);</span><br><span class="line">        list.forEach(node -&gt; &#123;</span><br><span class="line">            sj.add(node.toXml() + &quot;\n&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        return sj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通文本，我们把它看作<code>TextNode</code>，它没有子节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TextNode implements Node &#123;</span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    public TextNode(String text) &#123;</span><br><span class="line">        this.text &#x3D; text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node add(Node node) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Node&gt; children() &#123;</span><br><span class="line">        return List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toXml() &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还可以有注释节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CommentNode implements Node &#123;</span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    public CommentNode(String text) &#123;</span><br><span class="line">        this.text &#x3D; text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node add(Node node) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Node&gt; children() &#123;</span><br><span class="line">        return List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toXml() &#123;</span><br><span class="line">        return &quot;&lt;!-- &quot; + text + &quot; --&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ElementNode</code>、<code>TextNode</code>和<code>CommentNode</code>，我们就可以构造出一颗树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node root &#x3D; new ElementNode(&quot;school&quot;);</span><br><span class="line">root.add(new ElementNode(&quot;classA&quot;)</span><br><span class="line">        .add(new TextNode(&quot;Tom&quot;))</span><br><span class="line">        .add(new TextNode(&quot;Alice&quot;)));</span><br><span class="line">root.add(new ElementNode(&quot;classB&quot;)</span><br><span class="line">        .add(new TextNode(&quot;Bob&quot;))</span><br><span class="line">        .add(new TextNode(&quot;Grace&quot;))</span><br><span class="line">        .add(new CommentNode(&quot;comment...&quot;)));</span><br><span class="line">System.out.println(root.toXml());</span><br></pre></td></tr></table></figure><p>最后通过<code>root</code>节点输出的XML如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;school&gt;</span><br><span class="line">&lt;classA&gt;</span><br><span class="line">Tom</span><br><span class="line">Alice</span><br><span class="line">&lt;&#x2F;classA&gt;</span><br><span class="line">&lt;classB&gt;</span><br><span class="line">Bob</span><br><span class="line">Grace</span><br><span class="line">&lt;!-- comment... --&gt;</span><br><span class="line">&lt;&#x2F;classB&gt;</span><br><span class="line">&lt;&#x2F;school&gt;</span><br></pre></td></tr></table></figure><p>可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │   Node    │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼────────────┐</span><br><span class="line">      │            │            │</span><br><span class="line">┌───────────┐┌───────────┐┌───────────┐</span><br><span class="line">│ElementNode││ TextNode  ││CommentNode│</span><br><span class="line">└───────────┘└───────────┘└───────────┘</span><br></pre></td></tr></table></figure><p>作为容器节点的<code>ElementNode</code>又可以添加任意个<code>Node</code>，这样就可以构成层级结构。</p><p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure><p>最顶层的Component是接口，对应到IO的就是<code>InputStream</code>这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是<code>FileInputStream</code>、<code>ServletInputStream</code>这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code>FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code>BufferedInputStream</code>、<code>GZIPInputStream</code>等。</p><p>Decorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p><p>如果我们要自己设计完整的Decorator模式，应该如何设计？</p><p>我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p><p>首先，仍然需要定义顶层接口<code>TextNode</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface TextNode &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置text:</span><br><span class="line">    void setText(String text);</span><br><span class="line">    &#x2F;&#x2F; 获取text:</span><br><span class="line">    String getText();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于核心节点，例如<code>&lt;span&gt;</code>，它需要从<code>TextNode</code>直接继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SpanNode implements TextNode &#123;</span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    public void setText(String text) &#123;</span><br><span class="line">        this.text &#x3D; text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getText() &#123;</span><br><span class="line">        return &quot;&lt;span&gt;&quot; + text + &quot;&lt;&#x2F;span&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着，为了实现Decorator模式，需要有一个抽象的Decorator类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class NodeDecorator implements TextNode &#123;</span><br><span class="line">    protected final TextNode target;</span><br><span class="line"></span><br><span class="line">    protected NodeDecorator(TextNode target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setText(String text) &#123;</span><br><span class="line">        this.target.setText(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>NodeDecorator</code>类的核心是持有一个<code>TextNode</code>，即将要把功能附加到的<code>TextNode</code>实例。接下来就可以写一个加粗功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BoldDecorator extends NodeDecorator &#123;</span><br><span class="line">    public BoldDecorator(TextNode target) &#123;</span><br><span class="line">        super(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getText() &#123;</span><br><span class="line">        return &quot;&lt;b&gt;&quot; + target.getText() + &quot;&lt;&#x2F;b&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，可以继续加<code>ItalicDecorator</code>、<code>UnderlineDecorator</code>等。客户端可以自由组合这些Decorator：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TextNode n1 &#x3D; new SpanNode();</span><br><span class="line">TextNode n2 &#x3D; new BoldDecorator(new UnderlineDecorator(new SpanNode()));</span><br><span class="line">TextNode n3 &#x3D; new ItalicDecorator(new BoldDecorator(new SpanNode()));</span><br><span class="line">n1.setText(&quot;Hello&quot;);</span><br><span class="line">n2.setText(&quot;Decorated&quot;);</span><br><span class="line">n3.setText(&quot;World&quot;);</span><br><span class="line">System.out.println(n1.getText());</span><br><span class="line">&#x2F;&#x2F; 输出&lt;span&gt;Hello&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(n2.getText());</span><br><span class="line">&#x2F;&#x2F; 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;&#x2F;span&gt;&lt;&#x2F;u&gt;&lt;&#x2F;b&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(n3.getText());</span><br><span class="line">&#x2F;&#x2F; 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;&#x2F;span&gt;&lt;&#x2F;b&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>一手包办的中间人</p><blockquote><p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></blockquote><p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p><p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p><p>我们以注册公司为例，假设注册公司需要三步：</p><ol><li>向工商局申请公司营业执照；</li><li>在银行开设账户；</li><li>在税务局开设纳税号。</li></ol><p>以下是三个系统的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 工商注册:</span><br><span class="line">public class AdminOfIndustry &#123;</span><br><span class="line">    public Company register(String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 银行开户:</span><br><span class="line">public class Bank &#123;</span><br><span class="line">    public String openAccount(String companyId) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 纳税登记:</span><br><span class="line">public class Taxation &#123;</span><br><span class="line">    public String applyTaxCode(String companyId) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    public Company openCompany(String name) &#123;</span><br><span class="line">        Company c &#x3D; this.admin.register(name);</span><br><span class="line">        String bankAccount &#x3D; this.bank.openAccount(c.getId());</span><br><span class="line">        c.setBankAccount(bankAccount);</span><br><span class="line">        String taxCode &#x3D; this.taxation.applyTaxCode(c.getId());</span><br><span class="line">        c.setTaxCode(taxCode);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Company c &#x3D; facade.openCompany(&quot;Facade Software Ltd.&quot;);</span><br></pre></td></tr></table></figure><p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p><p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p><h3 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h3><blockquote><p>运用共享技术有效地支持大量细粒度的对象。</p></blockquote><p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p><p>类似创建<a href="####%E5%8D%95%E4%BE%8B">单例</a></p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><em>为其他对象提供一种代理以控制对这个对象的访问。</em></p><p>代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public BAdapter implements B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public BAdapter(A a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void b() &#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AProxy implements A &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public AProxy(A a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void a() &#123;</span><br><span class="line">        this.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？</p><p>当然不是。我们观察Proxy的实现A接口的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void a() &#123;</span><br><span class="line">    this.a.a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写当然没啥卵用。但是，如果我们在调用<code>a.a()</code>的前后，加一些额外的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void a() &#123;</span><br><span class="line">    if (getCurrentUser().isRoot()) &#123;</span><br><span class="line">        this.a.a();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new SecurityException(&quot;Forbidden&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。</p><p>有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？</p><p>因为我们编写代码的原则有：</p><ul><li>职责清晰：一个类只负责一件事；</li><li>易于测试：一次只测一个功能。</li></ul><p>用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：</p><ul><li>A接口：只定义接口；</li><li>ABusiness类：只实现A接口的业务逻辑；</li><li>APermissionProxy类：只实现A接口的权限检查代理。</li></ul><p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。</p><p>实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：</p><h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p><h4 id="虚代理"><a href="#虚代理" class="headerlink" title="虚代理"></a>虚代理</h4><p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p><h4 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h4><p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p><h4 id="智能引用"><a href="#智能引用" class="headerlink" title="智能引用"></a>智能引用</h4><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p><p>我们来看一下如何应用代理模式编写一个JDBC连接池（<code>DataSource</code>）。我们首先来编写一个虚代理，即如果调用者获取到<code>Connection</code>后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataSource lazyDataSource &#x3D; new LazyDataSource(jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line">System.out.println(&quot;get lazy connection...&quot;);</span><br><span class="line">try (Connection conn1 &#x3D; lazyDataSource.getConnection()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 并没有实际打开真正的Connection</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;get lazy connection...&quot;);</span><br><span class="line">try (Connection conn2 &#x3D; lazyDataSource.getConnection()) &#123;</span><br><span class="line">    try (PreparedStatement ps &#x3D; conn2.prepareStatement(&quot;SELECT * FROM students&quot;)) &#123; &#x2F;&#x2F; 打开了真正的Connection</span><br><span class="line">        try (ResultSet rs &#x3D; ps.executeQuery()) &#123;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getString(&quot;name&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来思考如何实现这个<code>LazyConnectionProxy</code>。为了简化代码，我们首先针对<code>Connection</code>接口做一个抽象的代理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractConnectionProxy implements Connection &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 抽象方法获取实际的Connection:</span><br><span class="line">    protected abstract Connection getRealConnection();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现Connection接口的每一个方法:</span><br><span class="line">    public Statement createStatement() throws SQLException &#123;</span><br><span class="line">        return getRealConnection().createStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PreparedStatement prepareStatement(String sql) throws SQLException &#123;</span><br><span class="line">        return getRealConnection().prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...其他代理方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>AbstractConnectionProxy</code>代理类的作用是把<code>Connection</code>接口定义的方法全部实现一遍，因为<code>Connection</code>接口定义的方法太多了，后面我们要编写的<code>LazyConnectionProxy</code>只需要继承<code>AbstractConnectionProxy</code>，就不必再把<code>Connection</code>接口方法挨个实现一遍。</p><p><code>LazyConnectionProxy</code>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class LazyConnectionProxy extends AbstractConnectionProxy &#123;</span><br><span class="line">    private Supplier&lt;Connection&gt; supplier;</span><br><span class="line">    private Connection target &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public LazyConnectionProxy(Supplier&lt;Connection&gt; supplier) &#123;</span><br><span class="line">        this.supplier &#x3D; supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 覆写close方法：只有target不为null时才需要关闭:</span><br><span class="line">    public void close() throws SQLException &#123;</span><br><span class="line">        if (target !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Close connection: &quot; + target);</span><br><span class="line">            super.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Connection getRealConnection() &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; null) &#123;</span><br><span class="line">            target &#x3D; supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用者没有执行任何SQL语句，那么<code>target</code>字段始终为<code>null</code>。只有第一次执行SQL语句时（即调用任何类似<code>prepareStatement()</code>方法时，触发<code>getRealConnection()</code>调用），才会真正打开实际的JDBC Connection。</p><p>最后，我们还需要编写一个<code>LazyDataSource</code>来支持这个<code>LazyConnecitonProxy</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class LazyDataSource implements DataSource &#123;</span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public LazyDataSource(String url, String username, String password) &#123;</span><br><span class="line">        this.url &#x3D; url;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Connection getConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">        return new LazyConnectionProxy(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Connection conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class="line">                System.out.println(&quot;Open connection: &quot; + conn);</span><br><span class="line">                return conn;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行代码，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get lazy connection...</span><br><span class="line">get lazy connection...</span><br><span class="line">Open connection: com.mysql.jdbc.JDBC4Connection@7a36aefa</span><br><span class="line">小明</span><br><span class="line">小红</span><br><span class="line">小军</span><br><span class="line">小白</span><br><span class="line">...</span><br><span class="line">Close connection: com.mysql.jdbc.JDBC4Connection@7a36aefa</span><br></pre></td></tr></table></figure><p>可见第一个<code>getConnection()</code>调用获取到的<code>LazyConnectionProxy</code>并没有实际打开真正的JDBC Connection。</p><p>使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataSource pooledDataSource &#x3D; new PooledDataSource(jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line">try (Connection conn &#x3D; pooledDataSource.getConnection()) &#123;</span><br><span class="line">&#125;</span><br><span class="line">try (Connection conn &#x3D; pooledDataSource.getConnection()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取到的是同一个Connection</span><br><span class="line">&#125;</span><br><span class="line">try (Connection conn &#x3D; pooledDataSource.getConnection()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取到的是同一个Connection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方并不关心是否复用了<code>Connection</code>，但从<code>PooledDataSource</code>获取的<code>Connection</code>确实自带这个优化功能。如何实现可复用<code>Connection</code>的连接池？答案仍然是使用代理模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class PooledConnectionProxy extends AbstractConnectionProxy &#123;</span><br><span class="line">    &#x2F;&#x2F; 实际的Connection:</span><br><span class="line">    Connection target;</span><br><span class="line">    &#x2F;&#x2F; 空闲队列:</span><br><span class="line">    Queue&lt;PooledConnectionProxy&gt; idleQueue;</span><br><span class="line"></span><br><span class="line">    public PooledConnectionProxy(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection target) &#123;</span><br><span class="line">        this.idleQueue &#x3D; idleQueue;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() throws SQLException &#123;</span><br><span class="line">        System.out.println(&quot;Fake close and released to idle queue for future reuse: &quot; + target);</span><br><span class="line">        &#x2F;&#x2F; 并没有调用实际Connection的close()方法,</span><br><span class="line">        &#x2F;&#x2F; 而是把自己放入空闲队列:</span><br><span class="line">        idleQueue.offer(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Connection getRealConnection() &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复用连接的关键在于覆写<code>close()</code>方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。</p><p>空闲队列由<code>PooledDataSource</code>负责维护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class PooledDataSource implements DataSource &#123;</span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 维护一个空闲队列:</span><br><span class="line">    private Queue&lt;PooledConnectionProxy&gt; idleQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(100);</span><br><span class="line"></span><br><span class="line">    public PooledDataSource(String url, String username, String password) &#123;</span><br><span class="line">        this.url &#x3D; url;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Connection getConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先试图获取一个空闲连接:</span><br><span class="line">        PooledConnectionProxy conn &#x3D; idleQueue.poll();</span><br><span class="line">        if (conn &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有空闲连接时，打开一个新连接:</span><br><span class="line">            conn &#x3D; openNewConnection();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Return pooled connection: &quot; + conn.target);</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private PooledConnectionProxy openNewConnection() throws SQLException &#123;</span><br><span class="line">        Connection conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.println(&quot;Open new connection: &quot; + conn);</span><br><span class="line">        return new PooledConnectionProxy(idleQueue, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行调用方代码，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Open new connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br></pre></td></tr></table></figure><p>除了第一次打开了一个真正的JDBC Connection，后续获取的<code>Connection</code>实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。</p><p>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</p><p>有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p><p>代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。</p><p>使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue中引入视频</title>
      <link href="/2021/01/16/Vue%E4%B8%AD%E5%BC%95%E5%85%A5%E8%A7%86%E9%A2%91/"/>
      <url>/2021/01/16/Vue%E4%B8%AD%E5%BC%95%E5%85%A5%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>Vue中适配的Video.js</p><p><a href="https://github.com/surmon-china/vue-video-player">Github链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.全局引用</span><br><span class="line">import VueVideoPlayer from &#39;vue-video-player&#39;</span><br><span class="line">import &#39;video.js&#x2F;dist&#x2F;video-js.css&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VideoPlayer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.组件内引用</span><br><span class="line">import &#123; videoPlayer &#125; from &#39;vue-video-player&#39;</span><br><span class="line">import &#39;video.js&#x2F;dist&#x2F;video-js.css&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    videoPlayer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html部分</span><br><span class="line"></span><br><span class="line">&lt;video-player  class&#x3D;&quot;video-player vjs-custom-skin&quot;</span><br><span class="line">     ref&#x3D;&quot;videoPlayer&quot;</span><br><span class="line">     :playsinline&#x3D;&quot;true&quot;</span><br><span class="line">     :options&#x3D;&quot;playerOptions&quot;</span><br><span class="line">&gt;&lt;&#x2F;video-player&gt;</span><br><span class="line">data部分</span><br><span class="line"></span><br><span class="line">playerOptions : &#123;</span><br><span class="line">        playbackRates: [0.7, 1.0, 1.5, 2.0], &#x2F;&#x2F;播放速度</span><br><span class="line">        autoplay: false, &#x2F;&#x2F;如果true,浏览器准备好时开始回放。</span><br><span class="line">        muted: false, &#x2F;&#x2F; 默认情况下将会消除任何音频。</span><br><span class="line">        loop: false, &#x2F;&#x2F; 导致视频一结束就重新开始。</span><br><span class="line">        preload: &#39;auto&#39;, &#x2F;&#x2F; 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持）</span><br><span class="line">        language: &#39;zh-CN&#39;,</span><br><span class="line">        aspectRatio: &#39;16:9&#39;, &#x2F;&#x2F; 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;）</span><br><span class="line">        fluid: true, &#x2F;&#x2F; 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。</span><br><span class="line">        sources: [&#123;</span><br><span class="line">          src: &#39;&#x2F;&#x2F;path&#x2F;to&#x2F;video.mp4&#39;,  &#x2F;&#x2F; 路径</span><br><span class="line">          type: &#39;video&#x2F;mp4&#39;  &#x2F;&#x2F; 类型</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          src: &#39;&#x2F;&#x2F;path&#x2F;to&#x2F;video.webm&#39;,</span><br><span class="line">          type: &#39;video&#x2F;webm&#39;</span><br><span class="line">        &#125;],</span><br><span class="line">        poster: &quot;..&#x2F;..&#x2F;static&#x2F;images&#x2F;test.jpg&quot;, &#x2F;&#x2F;你的封面地址</span><br><span class="line">        &#x2F;&#x2F; width: document.documentElement.clientWidth,</span><br><span class="line">        notSupportedMessage: &#39;此视频暂无法播放，请稍后再试&#39;, &#x2F;&#x2F;允许覆盖Video.js无法播放媒体源时显示的默认信息。</span><br><span class="line">        controlBar: &#123;</span><br><span class="line">          timeDivider: true,</span><br><span class="line">          durationDisplay: true,</span><br><span class="line">          remainingTimeDisplay: false,</span><br><span class="line">          fullscreenToggle: true  &#x2F;&#x2F;全屏按钮</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>登陆页面开发</title>
      <link href="/2021/01/15/%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
      <url>/2021/01/15/%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<ol><li>关于前后端结合</li></ol><p>前后端分离的意思是前后端之间通过 RESTful API 传递 JSON 数据</p><p>开发时，前端用前端的服务器，后端用后端的服务器。</p><p>前端服务器把前端请求结果从后端服务器拿到前端，称为反向代理。（常用Nginx）</p><ol start="2"><li>前端相关配置</li></ol><ul><li>设置反向代理<br>因为使用了新的模块 axios，所以需要进入到项目文件夹中，执行 npm install –save axios，以安装这个模块。</li></ul><p>修改 src\main.js 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置反向代理，前端请求默认发送到 http:&#x2F;&#x2F;localhost:8443&#x2F;api</span><br><span class="line">var axios &#x3D; require(&#39;axios&#39;)</span><br><span class="line">axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;localhost:8443&#x2F;api&#39;</span><br><span class="line">&#x2F;&#x2F; 全局注册，之后可在其他组件中通过 this.$axios 发送数据</span><br><span class="line">Vue.prototype.$axios &#x3D; axios</span><br></pre></td></tr></table></figure><ul><li>跨域支持<br>为了让后端能够访问到前端的资源，需要配置跨域支持。</li></ul><p>在 config\index.js 中，找到 proxyTable 位置，修改为以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:8443&#39;,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#39;^&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-elementUI安装及应用</title>
      <link href="/2021/01/15/Vue-elementUI%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2021/01/15/Vue-elementUI%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>Element 的官方地址为 <a href="http://element-cn.eleme.io/#/zh-CN">http://element-cn.eleme.io/#/zh-CN</a></p><ol><li><p>安装<br>在项目文件夹下，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure></li><li><p>引入</p></li></ol><ul><li>完整引入<ul><li>修改<code>main.js</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br><span class="line"># new Vue中</span><br><span class="line">render: h &#x3D;&gt; h(App)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js(三)</title>
      <link href="/2021/01/12/Vue-js-%E4%B8%89/"/>
      <url>/2021/01/12/Vue-js-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>Vue语法</p><ol><li>插值绑定</li></ol><ul><li>文本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#123;&#123;&#125;&#125;**</span><br></pre></td></tr></table></figure></li></ul><p>Vue会优先解释DOM节点中的标签，而变量中的仅当作文本处理<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;&#39;&lt;span&gt;15&lt;&#x2F;span&gt;&#39;&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;html&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script scoped&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data ()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            html : &#39;&lt;span&gt;15&lt;&#x2F;span&gt;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#39;15&#39;&#125;&#125;</span><br><span class="line">&lt;span&gt;15&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><ul><li>HTML<br>可以动态渲染DOM节点<br>开发者在使用HTML插值时应秉承以下原则：<ul><li>尽量多的使用Vue自身的模板机制，减少对HTML插值的使用</li><li>只对可信内容使用HTML插值</li><li>绝不相信用户输入的数据</li></ul></li></ul><ol start="2"><li>属性绑定</li></ol><ul><li><p>v-bind<br>DOM节点的属性基本都可以用v-bind绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-bind:class&#x3D;&quot;className&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            className: &#39;tureName&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>*v-bind<strong>也可以省略不写，直接使用 **:</strong></p></li><li><p>类名和样式绑定<br>类名本质为一个字符串数组，可以有多个。而样式为键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.color-gray&#123;color : gray;&#125;</span><br><span class="line">.size-18&#123;size : 18px;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p :class&#x3D;&quot;class1&quot;&gt;123123&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            class1: &#123; &#x2F;&#x2F;未绑定类名</span><br><span class="line">                &#39;color-gray&#39;: 0,</span><br><span class="line">                &#39;size-18&#39;: &#39;&#39;</span><br><span class="line">                &#x2F;&#x2F; 0 与 &#39;&#39; 均为 false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>针对不同的数据类型采用不同的渲染策略。</p></li></ul><ol start="3"><li>事件绑定</li></ol><ul><li><p>v-on 简写 <strong>@</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click&#x3D;&quot;demo()&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;demo()&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></li><li><p>常见修饰符<br>JS常见：<br>event.preventDefault() 阻止节点默认行为<br>event.stopPropagation() 阻止冒泡</p></li></ul><p>DOM中 event 发生时，首先自根部到发生时间的节点，再冒泡回根部，返回给浏览器。</p><pre><code>* .stop 阻止冒泡* .prevent 阻止默认行为* .capture 阻止事件捕获* .self 限制事件仅作用于自身节点* .once 触发一次就接触监听* .passive 移动端，可用事件（滚动） 限制事件永不调用preventDefault()方法</code></pre><ul><li>按键修饰符</li><li>*&lt;button @keyup.13=”console.log($event)”&gt;</button>**</li></ul><ul><li>组合修饰符<br>&lt;button @click.ctrl=”console.log($event)”&gt;</button></li></ul><ol start="4"><li>双向绑定</li></ol><ul><li>v-models</li></ul><ol start="5"><li>条件渲染与列表渲染</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js(二)</title>
      <link href="/2021/01/12/Vue-js-%E4%BA%8C/"/>
      <url>/2021/01/12/Vue-js-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>Vue 基本介绍</p><ul><li>生命周期<ul><li>create -&gt; insert data -&gt; 绑定el与模板 -&gt; render -&gt; Mount - - - &gt; destory</li></ul></li><li>数据响应式原理<ul><li>数据链<br>修改数据起点时，链路上所有的数据都将被更新</li><li>函数式编程<br>核心为<strong>根据元数据生成新的衍生数据，提供唯一的输入，函数将返回唯一确定的输出</strong></li><li>Vue中的数据链<br>提供了<strong>computed</strong>这一属性。只能以函数形式声明。（this表示当前vue实例）<br>demo：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    data ()&#123;</span><br><span class="line">        a: 3</span><br><span class="line">    &#125;</span><br><span class="line">    computed:&#123; &#x2F;&#x2F;计算属性</span><br><span class="line">        a()&#123;</span><br><span class="line">            return this.a * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li>数据绑定视图<br>内涵大致为赋值时使用setter，取值时使用getter，渲染时属性记录为依赖，setter被调用时会通知watcher将后面的依赖项的值更新。所以说这也就是为什么在已经渲染好的网页中，数据刚修改，在浏览器中就可以看到变化的原因。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js(一）</title>
      <link href="/2021/01/12/Vue-js-%E4%B8%80%EF%BC%89/"/>
      <url>/2021/01/12/Vue-js-%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>《Vue.js 从入门到项目实战》</p><p>（一） 引言</p><ul><li><p>发展历史<br>CGI(Common Gateway Interface)<br>动态数据与网页模板结合，送至服务端，服务器返回浏览器网页数据</p></li><li><p>Ajax</p></li><li><p>虚拟DOM</p></li><li><p>从MVC(Model View Controller)到MMVC(Model View Viewmodel)</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Server常用命令</title>
      <link href="/2020/12/07/Server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/12/07/Server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>买了好多服务器hhh，明明知道会吃灰也想买。总结一些常用的一键脚本叭。</p><ol><li><p>V2ray一键(233版本)<br>真的很方便，于是就偷懒干脆没看V2ray官方文档。不过大致流程还是有一些了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -s -L https:&#x2F;&#x2F;git.io&#x2F;v2ray.sh)</span><br><span class="line"></span><br><span class="line"># v2ray bbr 还可以更换内核</span><br></pre></td></tr></table></figure></li><li><p>NeteaseUnBlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 超级用户下</span><br><span class="line">wget -N --no-check-certificate raw.githubusercontent.com&#x2F;XIU2&#x2F;SHELL&#x2F;master&#x2F;unblock163.sh &amp;&amp; chmod +x unblock163.sh &amp;&amp; bash unblock163.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/oooldking/script">SuperBench</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lso- git.io&#x2F;superbench.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>CCAA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#海外</span><br><span class="line">bash &lt;(curl -Lsk https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helloxz&#x2F;ccaa&#x2F;master&#x2F;ccaa.sh)</span><br><span class="line">#国内</span><br><span class="line">bash &lt;(curl -Lsk https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helloxz&#x2F;ccaa&#x2F;master&#x2F;ccaa.sh)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/ytdl-org/youtube-dl">Youtube-dl</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https:&#x2F;&#x2F;yt-dl.org&#x2F;downloads&#x2F;latest&#x2F;youtube-dl -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;youtube-dl</span><br><span class="line">sudo chmod a+rx &#x2F;usr&#x2F;local&#x2F;bin&#x2F;youtube-dl</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><a href="eheh.org">EHEH</a><br>点击标题叭，服务器监控。我想之后我可能会用到。</p></li><li><p><a href="https://bt.cn/">BT</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 7.3 version(需要手机号登陆)</span><br><span class="line">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br><span class="line"></span><br><span class="line"># 5.9 version</span><br><span class="line">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>White-Jotter</title>
      <link href="/2020/12/05/White-Jotter/"/>
      <url>/2020/12/05/White-Jotter/</url>
      
        <content type="html"><![CDATA[<h1 id="跟着作者流程先来一遍"><a href="#跟着作者流程先来一遍" class="headerlink" title="跟着作者流程先来一遍"></a><a href="https://learner.blog.csdn.net/article/details/88926242">跟着作者流程先来一遍</a></h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li>安装及demo页<br><a href="https://cn.vuejs.org/v2/guide/">Vue官方教程</a></li></ul><ol><li>安装Vue-cli</li></ol><ul><li>安装nodejs(为了安装需要用的npm)</li><li>vue-cli<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br><span class="line"># 该方式安装的是2.9版本</span><br></pre></td></tr></table></figure></li></ul><p>3.x及以上版本安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure><p>新版本可以使用图形化界面初始化项目，并加入了项目健康监控的内容。</p><ol start="2"><li><p>构建前端项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入工作目录</span><br><span class="line">vue init webpack projectName</span><br><span class="line"># webpack 为模板项目</span><br><span class="line"># 默认则一路回车</span><br></pre></td></tr></table></figure></li><li><p>Vue项目结构分析</p></li></ol><ul><li>Vue Cli<ul><li>build(webpack初始化配置)</li><li>config(项目配置)</li><li>node_modules(项目依赖模块)</li><li><strong>src</strong> <ul><li>assets</li><li><strong>components</strong></li><li>route -&gt; <strong>index.js</strong></li><li>App.vue (根组件)</li><li>main.js(入口)</li></ul></li><li>static</li><li>test</li><li>index.html</li><li>package.json</li></ul></li></ul><h3 id="前端路由与登陆拦截器"><a href="#前端路由与登陆拦截器" class="headerlink" title="前端路由与登陆拦截器"></a>前端路由与登陆拦截器</h3><ol><li><p>前端路由</p><ul><li><p>Hash模式（即含#）</p><p>锚点，改变URL却不请求后端</p></li><li><p>History模式</p><p>使用了 <strong>History API</strong> </p><p>原理： 将页面状态保存到一个对象(state)中，当URL变化时，找到对应的对象，从而还原页面。本来是方便浏览器前进后退的。</p></li></ul></li><li><p>使用 <strong>History</strong> 模式</p><p>src/router/index.js 中添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode: <span class="string">&quot;history&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>前后端整合部署</p><ul><li><p>Vue项目文件夹中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>只有index.html一个页面，为单页面应用</p><p>因此，后端直接访问 <strong>/login</strong> 时服务器后端并没有内容。</p><p>为了获取到我们需要的内容，我们要设法触发前端路由，即在后端添加处理内容，把通过这个 URL 渲染出的 index.html 返回到浏览器。（个人认为是将实际文件路径指向index.html，而页面渲染是依据地址栏中的URL的，因此后端写code的时候只需要将这个页面用index.html补上就可以。</p></li></ul></li></ul></li><li><p>后端登陆拦截器</p><ul><li><p>简单逻辑</p><p>除login页面，均判断是否登陆，未登录 =&gt; 登陆， 已登录 =&gt; 访问。</p></li><li><p>实现（loginController）</p><ul><li>给session会话记录User值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LoginController</span><br><span class="line">&#x2F;&#x2F; 返回200前，添加settion</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class LoginController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @CrossOrigin</span><br><span class="line">    @PostMapping(value &#x3D; &quot;&#x2F;api&#x2F;login&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public Result login(@RequestBody User requestUser, HttpSession session) &#123;</span><br><span class="line">        String username &#x3D; requestUser.getUsername();</span><br><span class="line">        username &#x3D; HtmlUtils.htmlEscape(username);</span><br><span class="line"></span><br><span class="line">        User user &#x3D; userService.get(username, requestUser.getPassword());</span><br><span class="line">        if (null &#x3D;&#x3D; user) &#123;</span><br><span class="line">            return new Result(400);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">            return new Result(200);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>LoginIntercepter</p><p>拦截器，在spring boot中，我们可以直接继承拦截器的接口，然后实现 preHandle 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.evan.wj.interceptor;</span><br><span class="line"></span><br><span class="line">import com.evan.wj.pojo.User;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">public class LoginInterceptor  implements HandlerInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle (HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;</span><br><span class="line">        HttpSession session &#x3D; httpServletRequest.getSession();</span><br><span class="line">        String contextPath&#x3D;session.getServletContext().getContextPath();</span><br><span class="line">        String[] requireAuthPages &#x3D; new String[]&#123;</span><br><span class="line">                &quot;index&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        String uri &#x3D; httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">        uri &#x3D; StringUtils.remove(uri, contextPath+&quot;&#x2F;&quot;);</span><br><span class="line">        String page &#x3D; uri;</span><br><span class="line"></span><br><span class="line">        if(begingWith(page, requireAuthPages))&#123;</span><br><span class="line">            User user &#x3D; (User) session.getAttribute(&quot;user&quot;);</span><br><span class="line">            if(user&#x3D;&#x3D;null) &#123;</span><br><span class="line">                httpServletResponse.sendRedirect(&quot;login&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean begingWith(String page, String[] requiredAuthPages) &#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        for (String requiredAuthPage : requiredAuthPages) &#123;</span><br><span class="line">            if(StringUtils.startsWith(page, requiredAuthPage)) &#123;</span><br><span class="line">                result &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 <code>session</code> 中是否存在 <code>user</code> 属性，如果存在就放行，如果不存在就跳转到 <code>login</code> 页面。这里使用了一个路径列表（<code>requireAuthPages</code>），可以在里面写下需要拦截的路径。当然我们也可以拦截所有路径，那样就不用写这么多了，但会有逻辑上的问题，就是你访问了 <code>\login</code> 页面，仍然会需要跳转，这样就会引发多次重定向问题。</p></li><li><p>WebConfigurer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.evan.wj.config;</span><br><span class="line"></span><br><span class="line">import com.evan.wj.interceptor.LoginInterceptor;</span><br><span class="line">import org.springframework.boot.SpringBootConfiguration;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.*;</span><br><span class="line"></span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">public class MyWebConfigurer implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LoginInterceptor getLoginIntercepter() &#123;</span><br><span class="line">        return new LoginInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry)&#123;</span><br><span class="line">        registry.addInterceptor(getLoginIntercepter()).addPathPatterns(&quot;&#x2F;**&quot;).excludePathPatterns(&quot;&#x2F;index.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(getLoginIntercepter()).addPathPatterns(&quot;&#x2F;**&quot;).excludePathPatterns(&quot;&#x2F;index.html&quot;);</span><br></pre></td></tr></table></figure><p>这条语句的作用是对所有路径应用拦截器，除了 <code>/index.html</code>。</p><p>之前我们在拦截器 LoginInterceptor 中配置的路径，即 <code>index</code>，触发的时机是在拦截器生效之后。也就是说，我们访问一个 URL，会首先通过 Configurer 判断是否需要拦截，如果需要，才会触发拦截器 LoginInterceptor，根据我们自定义的规则进行再次判断。</p><p><code>/index</code> 与 <code>/index.html</code> 是不同的，也就是说 <code>/index</code> 会触发拦截器而 <code>/index.html</code> 不会，但根据拦截器 LoginInterceptor 中我们定义的判断条件，以 <code>/index</code> 开头的路径都会被转发，包括 <code>index.html</code>。</p><p>因为我们做的是单页面应用，之前通过配置 ErrorPage，实际上访问所有路径都会重定向到 <code>/index.html</code> 。我们直接在浏览器地址栏输入 <code>/index</code> 会触发拦截器，经过拦截器重定向到 <code>/login</code>，然后 <code>/login</code> 再经过 Configurer 的判断，再次触发拦截器，由于不在需要拦截的路径中，所以被放行，页面则重新定向到了 <code>/index.html</code>，如果没有再 Configurer 中取消对 <code>/index.html</code> 的拦截，则会再次触发拦截器，再次重定向到 <code>/login</code>，引发如下错误。</p></li></ul></li></ul></li><li><p>Vuex 与前端登录拦截器</p><p>前面我们使用了后端拦截器，但这种拦截器只有在将前后端项目整合在一起时才能生效，而前后端分离的项目实际上不推荐这么做，接下来我们尝试用前端实现相似的功能。</p></li></ol><p>   实现前端登录器，需要在前端判断用户的登录状态。我们可以像之前那样在组件的 data 中设置一个状态标志，但登录状态应该被视为一个<strong>全局属性</strong>，而不应该只写在某一组件中。所以我们需要引入一个新的工具——Vuex，它是专门为 Vue 开发的状态管理方案，我们可以把需要在各个组件中传递使用的变量、方法定义在这里。之前我一直没有使用它，所以在不同组件传值的问题上十分头疼，要写很多多余的代码来调用不同组件的值，所以推荐大家从一开始就去熟悉这种管理方式。</p><ul><li><p>引入 Vuex</p><p>在我们的项目文件夹中，运行 <code>npm install vuex --save</code>，之后，在 src 目录下新建一个文件夹 store，并在该目录下新建 index.js 文件，在该文件中引入 vue 和 vuex，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>之后，我们在 index.js 里设置我们需要的状态变量和方法。为了实现登录拦截器，我们需要一个记录用户信息的变量。为了方便日后的扩展（权限认证等），我们使用一个用户对象而不是仅仅使用一个布尔变量。同时，设置一个方法，触发这个方法时可以为我们的用户对象赋值。完整的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      username: window.localStorage.getItem(&#39;user&#39; || &#39;[]&#39;) &#x3D;&#x3D; null ? &#39;&#39; : JSON.parse(window.localStorage.getItem(&#39;user&#39; || &#39;[]&#39;)).username</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    login (state, user) &#123;</span><br><span class="line">      state.user &#x3D; user</span><br><span class="line">      window.localStorage.setItem(&#39;user&#39;, JSON.stringify(user))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们还用到了 <code>localStorage</code>，即本地存储，在项目打开的时候会判断本地存储中是否有 user 这个对象存在，如果存在就取出来并获得 <code>username</code> 的值，否则则把 <code>username</code> 设置为空。这样我们只要不清除缓存，登录的状态就会一直保存。</p></li><li><p>修改前端路由配置</p><p>为了区分页面是否需要拦截，我们需要修改一下 <code>src\router\index.js</code>，在需要拦截的路由中加一条元数据，设置一个 <code>requireAuth</code> 字段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     path: &#39;&#x2F;index&#39;,</span><br><span class="line">     name: &#39;AppIndex&#39;,</span><br><span class="line">     component: AppIndex,</span><br><span class="line">     meta: &#123;</span><br><span class="line">       requireAuth: true</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用钩子函数判断是否拦截</p><p>使用 <code>router.beforeEach()</code>，意思是在访问每一个路由前调用。</p><p>打开 <code>src\main.js</code> ，首先添加对 <code>store</code> 的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  render: h &#x3D;&gt; h(App),</span><br><span class="line">  router,</span><br><span class="line">  &#x2F;&#x2F; 注意这里</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着写 <code>beforeEach()</code> 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    if (to.meta.requireAuth) &#123;</span><br><span class="line">      if (store.state.user.username) &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        next(&#123;</span><br><span class="line">          path: &#39;login&#39;,</span><br><span class="line">          query: &#123;redirect: to.fullPath&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个的逻辑很简单，首先判断访问的路径是否需要登录，如果需要，判断 <code>store</code> 里有没有存储 <code>user</code> 的信息，如果存在，则放行，否则跳转到登录页面，并存储访问的页面路径（以便在登录后跳转到访问页）。</p></li></ul><pre><code> 完整： &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import Vue from &amp;#39;vue&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import App from &amp;#39;.&amp;#x2F;App&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import router from &amp;#39;.&amp;#x2F;router&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import store from &amp;#39;.&amp;#x2F;store&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import ElementUI from &amp;#39;element-ui&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &amp;#39;element-ui&amp;#x2F;lib&amp;#x2F;theme-chalk&amp;#x2F;index.css&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var axios &amp;#x3D; require(&amp;#39;axios&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;axios.defaults.baseURL &amp;#x3D; &amp;#39;http:&amp;#x2F;&amp;#x2F;localhost:8443&amp;#x2F;api&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.prototype.$axios &amp;#x3D; axios&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.config.productionTip &amp;#x3D; false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.use(ElementUI)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;router.beforeEach((to, from, next) &amp;#x3D;&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (to.meta.requireAuth) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if (store.state.user.username) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          path: &amp;#39;login&amp;#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          query: &amp;#123;redirect: to.fullPath&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;* eslint-disable no-new *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  el: &amp;#39;#app&amp;#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render: h &amp;#x3D;&amp;gt; h(App),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  router,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  store,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  components: &amp;#123; App &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  template: &amp;#39;&amp;lt;App&amp;#x2F;&amp;gt;&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre><ul><li><p>修改Login.vue</p><p>之前的登录组件中，我们只是判断后端返回的状态码，如果是 200，就重定向到首页。在经过前面的配置后，我们需要修改一下登录逻辑，以最终实现登录拦截。</p><p>修改后的逻辑如下：</p><p>1.点击登录按钮，向后端发送数据<br>2.受到后端返回的成功代码时，触发 <code>store</code> 中的 <code>login()</code> 方法，把 <code>loginForm</code> 对象传递给 <code>store</code> 中的 <code>user</code> 对象<br>（*这里只是简单的实现，在后端我们可以通过用户名和密码查询数据库，获得 user 表的完整信息，比如用户昵称、用户级别等，返回前端，并传递给 <code>user</code> 对象，以实现更复杂的功能）<br>3.获取登录前页面的路径并跳转，如果该路径不存在，则跳转到首页</p><p>修改后的 <code>login()</code> 方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">login () &#123;</span><br><span class="line">  var _this &#x3D; this</span><br><span class="line">  console.log(this.$store.state)</span><br><span class="line">  this.$axios</span><br><span class="line">    .post(&#39;&#x2F;login&#39;, &#123;</span><br><span class="line">      username: this.loginForm.username,</span><br><span class="line">      password: this.loginForm.password</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(successResponse &#x3D;&gt; &#123;</span><br><span class="line">      if (successResponse.data.code &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        &#x2F;&#x2F; var data &#x3D; this.loginForm</span><br><span class="line">        _this.$store.commit(&#39;login&#39;, _this.loginForm)</span><br><span class="line">        var path &#x3D; this.$route.query.redirect</span><br><span class="line">        this.$router.replace(&#123;path: path &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39; || path &#x3D;&#x3D;&#x3D; undefined ? &#39;&#x2F;index&#39; : path&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(failResponse &#x3D;&gt; &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;body id&#x3D;&quot;poster&quot;&gt;</span><br><span class="line">    &lt;el-form class&#x3D;&quot;login-container&quot; label-position&#x3D;&quot;left&quot;</span><br><span class="line">             label-width&#x3D;&quot;0px&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login_title&quot;&gt;系统登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;loginForm.username&quot;</span><br><span class="line">                  auto-complete&#x3D;&quot;off&quot; placeholder&#x3D;&quot;账号&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;loginForm.password&quot;</span><br><span class="line">                  auto-complete&#x3D;&quot;off&quot; placeholder&#x3D;&quot;密码&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item style&#x3D;&quot;width: 100%&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width: 100%;background: #505458;border: none&quot; v-on:click&#x3D;&quot;login&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;Login&#39;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        loginForm: &#123;</span><br><span class="line">          username: &#39;admin&#39;,</span><br><span class="line">          password: &#39;123&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        responseResult: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      login () &#123;</span><br><span class="line">        var _this &#x3D; this</span><br><span class="line">        console.log(this.$store.state)</span><br><span class="line">        this.$axios</span><br><span class="line">          .post(&#39;&#x2F;login&#39;, &#123;</span><br><span class="line">            username: this.loginForm.username,</span><br><span class="line">            password: this.loginForm.password</span><br><span class="line">          &#125;)</span><br><span class="line">          .then(successResponse &#x3D;&gt; &#123;</span><br><span class="line">            if (successResponse.data.code &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">              &#x2F;&#x2F; var data &#x3D; this.loginForm</span><br><span class="line">              _this.$store.commit(&#39;login&#39;, _this.loginForm)</span><br><span class="line">              var path &#x3D; this.$route.query.redirect</span><br><span class="line">              this.$router.replace(&#123;path: path &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39; || path &#x3D;&#x3D;&#x3D; undefined ? &#39;&#x2F;index&#39; : path&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(failResponse &#x3D;&gt; &#123;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  #poster &#123;</span><br><span class="line">    background:url(&quot;..&#x2F;assets&#x2F;eva.jpg&quot;) no-repeat;</span><br><span class="line">    background-position: center;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background-size: cover;</span><br><span class="line">    position: fixed;</span><br><span class="line">  &#125;</span><br><span class="line">  body&#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .login-container &#123;</span><br><span class="line">    border-radius: 15px;</span><br><span class="line">    background-clip: padding-box;</span><br><span class="line">    margin: 90px auto;</span><br><span class="line">    width: 350px;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    border: 1px solid #eaeaea;</span><br><span class="line">    box-shadow: 0 0 25px #cac6c6;</span><br><span class="line">  &#125;</span><br><span class="line">  .login_title &#123;</span><br><span class="line">    margin: 0px auto 40px auto;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #505458;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>输入账号密码后登录，成功跳转到 <a href="http://localhost:8080/index">http://localhost:8080/index</a> ，之后再次访问则无需登录（除非清除缓存）。</p></li></ul><h3 id="数据库设计与增删查改"><a href="#数据库设计与增删查改" class="headerlink" title="数据库设计与增删查改"></a>数据库设计与增删查改</h3><p>把拍脑袋想字段的过程称为数据库设计也是脸皮够厚，不过反正你们也不能顺着网线来打我。说起来也确实没啥需要认真琢磨的地方，等到之后做后台管理时可以把用户权限管理那一套东西整上，现在嘛，我们的需求大致如下：</p><ul><li>展示书籍的信息，包括封面、标题、作者、出版日期、出版社、摘要和分类。</li><li>维护分类信息。</li></ul><p>如果直接 clone 项目，因为我配置了自动注入的代码，直接运行项目就可以生成表结构（数据库需要手动创建）。关闭此功能，可以把 <code>application.properties</code> 中的如下代码注释掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每次运行时初始化数据库，如不需要可以注释掉</span><br><span class="line">spring.datasource.initialization-mode&#x3D;always</span><br></pre></td></tr></table></figure><p><strong>user 表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">char</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><strong>book 表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`book`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`book`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`cover`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">`author`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">`date`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">`press`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">`abs`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_book_category_on_cid`</span> (<span class="string">`cid`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_book_category_on_cid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`cid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`category`</span> (<span class="string">`id`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">102</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><p><strong>category 表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`category`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`category`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p>这里注意在 book 表在 cid 上有一个外键。</p><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>还是先看需求：</p><ul><li>查询书籍信息（查）</li><li>上传书籍信息（增）</li><li>修改书籍信息（改）</li><li>删除书籍信息（删）</li></ul><p>查询里涉及按关键字查询（图书检索），上传书籍信息里涉及图片上传，这里先不多说。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习</title>
      <link href="/2020/12/02/mysql%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/12/02/mysql%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>SQL语言定义了这么几种操作数据库的能力：</p><p><strong>DDL：Data Definition Language</strong></p><p>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p><p><strong>DML：Data Manipulation Language</strong></p><p>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p><p><strong>DQL：Data Query Language</strong></p><p>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p><ul><li>语法特点</li></ul><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p><p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>&#39;&#39;</code>。</p><p> 通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p><table><thead><tr><th align="left">id</th><th align="left">class_id</th><th align="left">name</th><th align="left">gender</th><th align="left">score</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">小明</td><td align="left">M</td><td align="left">90</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">小红</td><td align="left">F</td><td align="left">95</td></tr></tbody></table><p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p><p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。</p><p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p><ol><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p><p> 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p><h5 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h5><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p><table><thead><tr><th align="left">id_num</th><th align="left">id_type</th><th align="left">other columns…</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">A</td><td align="left">…</td></tr><tr><td align="left">2</td><td align="left">A</td><td align="left">…</td></tr><tr><td align="left">2</td><td align="left">B</td><td align="left">…</td></tr></tbody></table><p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p><p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">other columns…</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小明</td><td align="left">…</td></tr><tr><td align="left">2</td><td align="left">小红</td><td align="left">…</td></tr></tbody></table><p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">other columns…</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">一班</td><td align="left">…</td></tr><tr><td align="left">2</td><td align="left">二班</td><td align="left">…</td></tr></tbody></table><p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p><table><thead><tr><th align="left">id</th><th align="left">class_id</th><th align="left">name</th><th align="left">other columns…</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">小明</td><td align="left">…</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">小红</td><td align="left">…</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">小白</td><td align="left">…</td></tr></tbody></table><p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p><p>例如：</p><ul><li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li></ul><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">张老师</td></tr><tr><td align="left">2</td><td align="left">王老师</td></tr><tr><td align="left">3</td><td align="left">李老师</td></tr><tr><td align="left">4</td><td align="left">赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">一班</td></tr><tr><td align="left">2</td><td align="left">二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th align="left">id</th><th align="left">teacher_id</th><th align="left">class_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">2</td></tr><tr><td align="left">3</td><td align="left">2</td><td align="left">1</td></tr><tr><td align="left">4</td><td align="left">2</td><td align="left">2</td></tr><tr><td align="left">5</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left">6</td><td align="left">4</td><td align="left">2</td></tr></tbody></table><p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p><ul><li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li><li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li></ul><p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p><ul><li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li><li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p><table><thead><tr><th align="left">id</th><th align="left">student_id</th><th align="left">mobile</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">135xxxx6300</td></tr><tr><td align="left">2</td><td align="left">2</td><td align="left">138xxxx2209</td></tr><tr><td align="left">3</td><td align="left">5</td><td align="left">139xxxx8086</td></tr></tbody></table><p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">class_id</th><th align="left">name</th><th align="left">gender</th><th align="left">score</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">小明</td><td align="left">M</td><td align="left">90</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">小红</td><td align="left">F</td><td align="left">95</td></tr><tr><td align="left">3</td><td align="left">1</td><td align="left">小军</td><td align="left">M</td><td align="left">88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p><p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT uni_name UNIQUE (name);</span><br></pre></td></tr></table></figure><p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>通过对数据库表创建索引，可以提高查询速度。</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。</p><p>SELECT查询的结果是一个二维表。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>manim安装-ubuntu16.04</title>
      <link href="/2020/12/01/manim%E5%AE%89%E8%A3%85-ubuntu16-04/"/>
      <url>/2020/12/01/manim%E5%AE%89%E8%A3%85-ubuntu16-04/</url>
      
        <content type="html"><![CDATA[<p>每次上网搜索感到有些白费力。遂整理，之后有空再写成一键脚本。</p><ul><li><p>检查Python版本<br>  习惯装ubuntu16.04，自带python为3.5，不支持manim，先更新python</p><p>  不行，还是换18方便一点，，，，，</p><h2 id="更新Python至3-8"><a href="#更新Python至3-8" class="headerlink" title="更新Python至3.8"></a>更新Python至3.8</h2><h3 id="通过apt安装"><a href="#通过apt安装" class="headerlink" title="通过apt安装"></a>通过apt安装</h3><p>由于官方源暂未收录<strong>python3.8</strong>,所以这里使用 <strong>deadsnakes ppa</strong> 库</p><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software-properties-common</span><br></pre></td></tr></table></figure><h4 id="添加-deadsnakes-源"><a href="#添加-deadsnakes-源" class="headerlink" title="添加 deadsnakes 源"></a>添加 deadsnakes 源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes&#x2F;ppa</span><br><span class="line"></span><br><span class="line"># 按下Enter</span><br></pre></td></tr></table></figure><h4 id="安装-Python3-8"><a href="#安装-Python3-8" class="headerlink" title="安装 Python3.8"></a>安装 Python3.8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3.8</span><br></pre></td></tr></table></figure><h4 id="将python3与Python3-8-关联"><a href="#将python3与Python3-8-关联" class="headerlink" title="将python3与Python3.8 关联"></a>将<strong>python3</strong>与Python3.8 关联</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">which python3.8</span><br><span class="line"># print &#x2F;usr&#x2F;bin&#x2F;python3.8</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python3 python3 &#x2F;usr&#x2F;bin&#x2F;python3.8 1</span><br><span class="line"># 查看自带python版本，ubuntu18默认3.6</span><br><span class="line">which python3.6</span><br><span class="line"># print &#x2F;usr&#x2F;bin&#x2F;python3.6</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python3 python3 &#x2F;usr&#x2F;bin&#x2F;python3.6 2</span><br><span class="line"></span><br><span class="line">update-alternatives --config python3</span><br><span class="line"># 输入python3.8 对应的序号 默认应为 2</span><br><span class="line"></span><br><span class="line"># 检查</span><br><span class="line">python3 -V</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="安装-pip3"><a href="#安装-pip3" class="headerlink" title="安装 pip3"></a>安装 pip3</h2><ol><li><p>apt 安装(便于卸载)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure></li><li><p>通过官方文件安装(报bug少)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py -o get-pip.py</span><br><span class="line">sudo python3 get-pip.py</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装-Manim"><a href="#安装-Manim" class="headerlink" title="安装 Manim"></a>安装 Manim</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 安装Tex</span><br><span class="line">sudo apt-get install texlive-full</span><br><span class="line"></span><br><span class="line"># 安装依赖工具等</span><br><span class="line">sudo apt-get install ffmpeg sox libcairo2-dev libjpeg-dev libgif-dev python3-dev libffi-dev</span><br><span class="line"></span><br><span class="line"># 安装python相关库</span><br><span class="line">python3 -m pip install pyreadline</span><br><span class="line">python3 -m pip install pydub</span><br><span class="line"></span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;3b1b&#x2F;manim.git</span><br><span class="line"># 拉取</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;3b1b&#x2F;manim.git</span><br><span class="line"></span><br><span class="line">cd manim</span><br><span class="line"># 安装相关依赖</span><br><span class="line">python3 -m pip install -r requirements.txt</span><br><span class="line"># 安装不成功先试试升级pip3</span><br><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 进入manim文件夹</span><br><span class="line">python3 -m manim example_scenes.py WriteStuff -l</span><br></pre></td></tr></table></figure><h2 id="安装成功！"><a href="#安装成功！" class="headerlink" title="安装成功！"></a>安装成功！</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>欧美影视下载</title>
      <link href="/2020/11/17/mgdl/"/>
      <url>/2020/11/17/mgdl/</url>
      
        <content type="html"><![CDATA[<h3 id="不论是观影还是下载影片，都推荐在PC端进行"><a href="#不论是观影还是下载影片，都推荐在PC端进行" class="headerlink" title="不论是观影还是下载影片，都推荐在PC端进行"></a>不论是观影还是下载影片，都推荐在PC端进行</h3><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ul><li>下载种子或获取磁力链接</li><li>将以上提交服务器开始下载</li><li>将文件拉回本地</li><li>删除远端文件</li></ul><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><ul><li><p>下载种子或获取磁力链接</p><ul><li>开启代理</li><li>打开<a href="https://rarbgprx.org/torrents.php?category=movies">https://rarbgprx.org/torrents.php?category=movies</a></li><li>左侧选择要搜索的类目（例如电影或是TV Show）</li><li>中间搜索你想要看的电影或节目，注意一定要用英文名<ul><li>例如：少年的你 则搜索 Better Days</li><li>不知道英文名可以先百度</li></ul></li><li>搜索完在下面根据名称日期预览图等挑选一个，单击之后会跳到详情页面</li><li>第一行<strong>Torrent</strong>，点击旁边的链接就可以下载种子文件，右边红色小磁铁就是磁力链接。（建议使用种子）</li></ul></li><li><p>将以上提交服务器开始下载</p><ul><li>浏览器新开标签页打开<a href="https://u.nu/mgdl">https://u.nu/mgdl</a>（MG Download）</li><li>AriaNg认证<ul><li>左边标签选择<strong>Aria2Ng</strong>设置，然后在页面左上找到<strong>全局</strong>旁边的<strong>RPC</strong>选项卡，单击</li><li>Aria2 RPC 密钥一栏填写<strong>657286</strong>，刷新页面</li></ul></li><li>创建下载任务<ul><li>页面左上找到<strong>新建</strong>,单击</li><li><strong>立即下载</strong>按钮旁边有文件夹字样，单击上传刚刚下载好的种子文件</li><li><strong>立即下载</strong></li></ul></li><li>等待下载完成<ul><li>下载速度取决于资源热度</li></ul></li></ul></li><li><p>将文件拉回本地</p><ul><li>再次打开<a href="https://u.nu/mg-dl">https://u.nu/mg-dl</a></li><li>点击左侧菜单栏最后一项<strong>文件管理</strong></li><li>登陆<ul><li>账号： <strong>ccaa</strong></li><li>密码： <strong>admin</strong></li></ul></li><li>找到自己的文件<ul><li>单击，底色变蓝说明已经选中</li><li>右上角点击下载图标，开始下载</li></ul></li><li>下载完成<ul><li>请将下载完的文件删除，因为服务器外存有限</li><li>选中，点击右上垃圾桶按钮即可</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Q-learning</title>
      <link href="/2020/10/08/Q-learning/"/>
      <url>/2020/10/08/Q-learning/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2020/10/08/BagProblems/"/>
      <url>/2020/10/08/BagProblems/</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>背包容量j一定，现有一些物品，分别对应有质量w和体积v，求背包可容纳物品重量最大的方案。</p><ol><li><p>0-1背包问题<br>列举的物品均只有一件。<br>状态转移方程：<br>Dp[i][j] = max{Dp[i-1][j-item.v]+item.w, Dp[i-1][j]}</p><h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h5><p>因为计算i行，只用到i-1行的数据，因此可以只用一个数组，而在更新数据时，应从j到0，避免同一物品被用多次。</p></li><li><p>完全背包问题<br>列举的物品有无穷多件。<br>转换为优化方案，状态转移时，从0到j。</p></li><li><p>多重背包问题<br>界于0-1与完全背包之间，列举的物品可以有不同的数量，不同的质量和体积。</p></li></ol><ul><li>将属性相同的物体可以视为不同物体，转换为0-1背包问题<br>  缺点：时间复杂度较大<br>改进方案：</li><li>将属性相同的物体以2的c次幂分组绑定，视为不同物体，最终质量和为所有原物体的质量和。再转换为0-1背包。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>匈牙利算法</title>
      <link href="/2020/09/03/searchextremum/"/>
      <url>/2020/09/03/searchextremum/</url>
      
        <content type="html"><![CDATA[<p>匈牙利算法用来解决一种特殊的指派问题。</p><h3 id="Layman对指派问题的解释"><a href="#Layman对指派问题的解释" class="headerlink" title="Layman对指派问题的解释"></a>Layman对指派问题的解释</h3><p>你有三个工人：吉姆，史提夫和艾伦。 你需要其中一个清洁浴室，另一个打扫地板，第三个洗窗，但他们每个人对各项任务要求不同数目数量的钱。 以最低成本的分配工作的方式是什么？ 可以用工人做工的成本矩阵来表示该问题。例如：</p><table class="wikitable" border="1"><tbody><tr><th></th><th>清洁浴室</th><th>打扫地板</th><th>洗窗</th></tr><tr><th>吉姆</th><td>$2</td><td>$3</td><td>$3</td></tr><tr><th>史提夫</th><td>$3</td><td>$2</td><td>$3</td></tr><tr><th>艾伦</th><td>$3</td><td>$3</td><td>$2</td></tr></tbody></table><p>当把匈牙利方法应用于上面的表格时，会给出最低成本：为6美元，让吉姆清洁浴室、史提夫打扫地板、艾伦清洗窗户就可以达到这一结果。</p><h3 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h3><p>设价值矩阵c（n×n）,分配矩阵x（n×n）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信订阅华工教务处通知</title>
      <link href="/2020/08/08/subscribe/"/>
      <url>/2020/08/08/subscribe/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>该服务目前处于内测阶段，对意外的情况容忍度较低，之后会不断修复。目前请按照严格按照教程操作。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>微信账号</li><li>GitHub账号  <a href="https://jingyan.baidu.com/article/4e5b3e192200e291911e2468.html">点击查看如何注册</a></li></ul><h1 id="订阅步骤"><a href="#订阅步骤" class="headerlink" title="订阅步骤"></a>订阅步骤</h1><h2 id="关注公众号“二茂铁Fe”"><a href="#关注公众号“二茂铁Fe”" class="headerlink" title="关注公众号“二茂铁Fe”"></a>关注公众号“二茂铁Fe”</h2><p><img src="https://1b.mk/images/wechat_channel.jpg" alt="QR-Code"></p><h2 id="微信绑定Server酱，获取SCKEY"><a href="#微信绑定Server酱，获取SCKEY" class="headerlink" title="微信绑定Server酱，获取SCKEY"></a>微信绑定Server酱，获取SCKEY</h2><p><a href="https://sc.ftqq.com/">Server酱</a>地址：<a href="https://sc.ftqq.com/">点击访问</a><br><img src="https://1b.mk/images/sub_step_1.png" alt="DemoShow"></p><ul><li>步骤也很简单<ul><li>登入：用GitHub账号登入网站，切记要点击右下角的<strong>GITHUB一键登入</strong> <strong>（请于PC端打开，若只有手机，请将浏览器UA调为PC）</strong></li><li>绑定：点击「微信推送」，扫码关注“方糖”，按提示绑定微信。</li><li>最后点击<strong>发送消息</strong>查看自己的SCKEY，请将其复制到剪切板。</li></ul></li></ul><h2 id="添加订阅通知"><a href="#添加订阅通知" class="headerlink" title="添加订阅通知"></a>添加订阅通知</h2><ul><li>返回“二茂铁Fe”,发送  <strong>订阅通知</strong> （四个字）</li><li>按照格式发送自己的SCKEY</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 实时推送</span><br><span class="line">SCKEY xxxxxxxx</span><br><span class="line"></span><br><span class="line"># 每日推送</span><br><span class="line">SCKEY 1 xxxxx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看消息列表"><a href="#查看消息列表" class="headerlink" title="查看消息列表"></a>查看消息列表</h2><ul><li>若出现了测试信息，那么恭喜你，订阅成功！</li></ul><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>很抱歉，由于我的微信公众号为个人号，无法申请到直接推送消息的权限，因此只能借助“Easy”的ServerChan来实现主动推送，导致整个流程变得繁琐。目前程序仍然存在很多不完善的地方，仍需改进。我将代码放在<a href="https://github.com/Ermaotie/Q-A-Robot">这里</a>,如果觉得该项目有用的话，请给我一颗星星。最后，欢迎志同道合的朋友一起来完善它！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>影视解析--前端学习(html+js+css)</title>
      <link href="/2020/07/23/%E5%BD%B1%E8%A7%86%E8%A7%A3%E6%9E%90-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-html-js-css/"/>
      <url>/2020/07/23/%E5%BD%B1%E8%A7%86%E8%A7%A3%E6%9E%90-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-html-js-css/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>其实我对影视VIP的需求并不是很大，很多时候只是听到身边其他人的推荐抑或是网上很火且能吸引我的作品，才会去购买。不过朋友圈里倒是好多苦不堪言的状况，喜欢看的综艺节目总是在不同的平台上，而如果不是合租的话，一个普通大学生是不太情愿去购买多家视频网站会员的。因此，解析网站就成了一个可行的选择，当然大多数解析网站会有大量的广告。而在这里，我筛选了一些无广告或者说几乎无广告的API。<br><a href="https://github.com/Ermaotie/MoviesParsing">Github</a><br><a href="http://movie.1b.mk/">演示Demo</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>已有的接口<br>其实这个API才是各种影视解析网站的核心, 当然写这个有一定的难度，不过就现在，我们只要调用就可以了。</li><li>Github page 或 域名及空间<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2>如果只要基本功能的实现，几行html，再加上一句js就完全搞定了。<h3 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h3></li><li>目标url = 接口 + 输入网址</li><li>跳转到目标 url<h2 id="具体优化"><a href="#具体优化" class="headerlink" title="具体优化"></a>具体优化</h2><h3 id="提高兼容性"><a href="#提高兼容性" class="headerlink" title="提高兼容性"></a>提高兼容性</h3>由于语言的多样性，而HTML又可以显示不同的语言，所以要在<head>中声明自己的doc是什么类型的，如何编码的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># HTML4</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&#x2F;&gt;</span><br><span class="line"># HTML5</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="页面背景优化"><a href="#页面背景优化" class="headerlink" title="页面背景优化"></a>页面背景优化</h3>最开始计划是放一张智子的图片，但是国内对Github Page不太友好，所以使用js生成漂亮的背景：<br>这里放链接吧，原作写的太好看了。<a href="https://www.html.cn/archives/8722">点击链接</a><h4 id="需要注意的是，示例中给的放在了-lt-div-gt-下，但是放在-lt-div-gt-下会导致页面上方有一条黑边，我想是div标签的bug吧。因为是背景，所以直接选择body即可"><a href="#需要注意的是，示例中给的放在了-lt-div-gt-下，但是放在-lt-div-gt-下会导致页面上方有一条黑边，我想是div标签的bug吧。因为是背景，所以直接选择body即可" class="headerlink" title="需要注意的是，示例中给的放在了&lt;div&gt;下，但是放在&lt;div&gt;下会导致页面上方有一条黑边，我想是div标签的bug吧。因为是背景，所以直接选择body即可"></a>需要注意的是，示例中给的放在了&lt;div&gt;下，但是放在&lt;div&gt;下会导致页面上方有一条黑边，我想是div标签的bug吧。因为是背景，所以直接选择body即可</h4><h3 id="跳转按钮以及其他部件优化"><a href="#跳转按钮以及其他部件优化" class="headerlink" title="跳转按钮以及其他部件优化"></a>跳转按钮以及其他部件优化</h3>也是通过加标签class或id，再通过CSS选择器，设置对应参数。</li><li>强制居中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">    text-align: center; &#x2F;*让div内部文字居中*&#x2F;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    border-radius: 20px;</span><br><span class="line">    width: 290px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin: auto;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://chinese.freecodecamp.org/forum/t/topic/292/2">按键优化</a><br>鼠标位于btn上方时文字滑动浮现，离开滑动渐隐。span标签在button里，用于承载文字。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.button &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    background-color: #f3974c;</span><br><span class="line">    border: none;</span><br><span class="line">    color: #FFFFFF;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    transition: all 0.5s;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    margin: 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  .button span &#123;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    position: relative;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">  &#125;</span><br><span class="line">  .button span:after &#123;</span><br><span class="line">  content: &#39;\00bb&#39;;  &#x2F;* CSS Entities. 如果用的是 HTML Entities, 请改成 &amp;#8594;*&#x2F;</span><br><span class="line">  position: absolute;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: -20px;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">  &#125;</span><br><span class="line">  .button:hover span &#123;</span><br><span class="line">    padding-right: 25px;</span><br><span class="line">  &#125;</span><br><span class="line">  .button:hover span:after &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">    right: 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>&lt;input&gt;框优化<br>圆角及选中荧光<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#input</span><br><span class="line">&#123;</span><br><span class="line">    outline-style: none ;</span><br><span class="line">    border-width: 1px;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">&#125;</span><br><span class="line">#input:focus&#123;</span><br><span class="line">    border-color: #66afe9;</span><br><span class="line">    outline: 0;</span><br><span class="line">    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);</span><br><span class="line">    box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2>又开了一个新坑，发现前端似乎也挺有意思的。在平时的日常生活中，总能发现一些给人耳目一新的一些网页的效果，很值得我们不断去学习。当然js也不止可以让网页变得好看，还可以实现更多复杂的逻辑目的。这些都等着我去学习。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>配置Hexo 并使用gitalk</title>
      <link href="/2020/07/19/%E9%85%8D%E7%BD%AEHexo-%E5%B9%B6%E4%BD%BF%E7%94%A8gitalk/"/>
      <url>/2020/07/19/%E9%85%8D%E7%BD%AEHexo-%E5%B9%B6%E4%BD%BF%E7%94%A8gitalk/</url>
      
        <content type="html"><![CDATA[<h2 id="安装所需环境"><a href="#安装所需环境" class="headerlink" title="安装所需环境"></a>安装所需环境</h2><ul><li><p>Hexo 基于 Node.js，并使用npm管理器安装，若需要安置在github上，则也需要安装git</p><ul><li><p>安装</p></li><li><p>换源</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>更换国内淘宝源(长期生效)：</p><p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></li></ul></li></ul><h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><h3 id="Hexo概述"><a href="#Hexo概述" class="headerlink" title="Hexo概述"></a>Hexo概述</h3><p>Hexo 是一款可以通过git工具，发布静态博文的一款优秀博客系统。它最重要的特点就是<strong>轻便</strong>，<strong>轻</strong>且<strong>便</strong></p><h3 id="Hexo官方文档"><a href="#Hexo官方文档" class="headerlink" title="Hexo官方文档"></a><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></h3><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><pre><code># 全局安装npm install -g hexo-cli</code></pre><h3 id="使用Hexo-1"><a href="#使用Hexo-1" class="headerlink" title="使用Hexo"></a>使用Hexo</h3><h4 id="初始化Hexo文件夹"><a href="#初始化Hexo文件夹" class="headerlink" title="初始化Hexo文件夹"></a>初始化Hexo文件夹</h4><p>控制台中打开所要初始化的文件夹</p><pre><code>hexo init</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>新建xxx</p><pre><code>hexo new demoTitlehexo new page &quot;demoPage&quot;hexo new tag &quot;demoTag&quot;hexo new category &quot;demoName&quot;</code></pre><p>维护使用</p><pre><code># 清除原有生成的静态博客hexo clean# 生成静态博客hexo g  # hexo generate# 部署（到github）hexo d  # hexo deploy# 本地查看 http://localhost:4000hexo s  # hexo server</code></pre><h2 id="安装Next"><a href="#安装Next" class="headerlink" title="安装Next"></a>安装Next</h2><p>下载<a href="https://github.com/iissnan/hexo-theme-next">github项目Next</a>这里使用的是低版本，已停止维护。7.0以上自动集成gitalk，到配置文件中打开即可。<br>下载至hexo/theme中</p><h2 id="配置gitalk"><a href="#配置gitalk" class="headerlink" title="配置gitalk"></a>配置gitalk</h2><p>详情见<a href="https://www.itfanr.cc/2019/04/30/hexo-add-gitalk-comment/">此</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS仿真（simulation）(一)</title>
      <link href="/2020/07/18/ROS%E4%BB%BF%E7%9C%9F%EF%BC%88simulation%EF%BC%89-%E4%B8%80/"/>
      <url>/2020/07/18/ROS%E4%BB%BF%E7%9C%9F%EF%BC%88simulation%EF%BC%89-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>SLAM仿真建图：</p><pre><code># 打开一个地图文件，并带有一个仿真机器人roslaunch turtlebot3_gazebo turtlebot3_world.launch# 运行SLAM启动文件，启动RVIZroslaunch turtlebot3_slam turtlebot3_slam.launch# 运行键盘控制roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch# 建图完毕后，保存地图rosrun map_server map_saver -f ~/map# 保存到~/ 下 “上面的~/是指 topic中”</code></pre><p>仿真导航：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打开一个地图文件，并带有一个仿真机器人</span><br><span class="line">roslaunch turtlebot3_gazebo turtlebot3_world.launch</span><br><span class="line"></span><br><span class="line"># 依赖于保存好的map.pgm</span><br><span class="line">roslaunch turtlebot3_navigation turtlebot3_navigation.launch map_file:&#x3D;$HOME&#x2F;map.yaml</span><br></pre></td></tr></table></figure><ul><li>要给出初始数据，请按照说明进行操作。 <ul><li>点击2D Pose Estimate按钮</li><li>通过单击并拖动地图上的方向来设置地图上的大致位置。</li><li>箭头的每个点意味着TurtleBot3的预期姿势。激光扫描仪将在近似位置绘制线条，如地图上的墙壁。</li><li>要发送目标位置：</li><li>点击 2D Nav Goal按钮</li><li>点击地图上你想要的TurtleBot驱动和拖动方向TurtleBot应该指向地方</li><li>要在机器人到达目标位置之前停止机器人，请发送TurtleBot3的当前位置。</li></ul></li></ul><p>需要已经启动机器人</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 开机自启运行脚本</title>
      <link href="/2020/07/18/Ubuntu-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/07/18/Ubuntu-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<ol><li>将脚本文件放在 <code>/etc/init.d/</code> 下<br>脚本格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides:          1bmk</span><br><span class="line"># Required-Start:    $local_fs $network</span><br><span class="line"># Required-Stop:     $local_fs</span><br><span class="line"># Default-Start:     2 3 4 5</span><br><span class="line"># Default-Stop:      0 1 6</span><br><span class="line"># Short-Description: self define auto start</span><br><span class="line"># Description:       self define auto start</span><br><span class="line">### END INIT INFO</span><br><span class="line">sudo ntpdate pool.ntp.org</span><br></pre></td></tr></table></figure></li><li>加权限 <code> sudo chmod +x demo.sh</code></li><li><code>sudo update-rc.d demo.sh defaults 90</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>turtlebot安装BUG (ubuntu18.04+melodic)</title>
      <link href="/2020/07/15/turtlebot%E5%AE%89%E8%A3%85BUG-ubuntu18-04-melodic/"/>
      <url>/2020/07/15/turtlebot%E5%AE%89%E8%A3%85BUG-ubuntu18-04-melodic/</url>
      
        <content type="html"><![CDATA[<p>教程：<a href="https://www.ncnynl.com/archives/201903/2884.html">创客制造</a></p><p>第一个错是缺失urdf（– Could NOT find urdf (missing: urdf_DIR)）：<br>解决方法：先卸载：sudo apt-get remove ros-melodic-*<br>再重新按照官方教程安装：<a href="http://wiki.ros.org/melodic/Installation/Ubuntu">http://wiki.ros.org/melodic/Installation/Ubuntu</a></p><p>第二个错：Could not find a package configuration file provided by “ecl_threads” with any of the following names:<br>解决方法：sudo apt-get install ros-melodic-ecl-threads<br>第三个错：Could not find a package configuration file provided by ‘ecl_geometry’<br>解决方法：sudo apt-get install ros-melodic-ecl-geometry</p><p>第四个错：Could not find a package configuration file provided by “kobuki_dock_drive”<br>解决方法：sudo apt-get install ros-melodic-kobuki-dock-drive</p><p>第五个错：No package ‘orocos-bfl’ found<br>解决方法：sudo apt-get install ros-melodic-bfl</p><p>第六个错：Could not find a package configuration file provided by “kobuki_driver”<br>解决方法：sudo apt-get install ros-melodic-kobuki-driver</p><p>第七个错： Could not find a package configuration file provided by “ecl_streams” with any of the following names:<br>解决方法：sudo apt-get install ros-melodic-ecl-streams</p><p>第八个错：/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp: In member function ‘void keyop_core::KeyOpCore::remoteKeyInputReceived(const KeyboardInput&amp;)’:<br>/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp:274:28: error: ‘const KeyboardInput {aka const struct kobuki_msgs::KeyboardInput_}’ has no member named ‘pressed_key’; did you mean ‘pressedKey’?<br>processKeyboardInput(key.pressed_key);<br>^<del>~<br>pressedKey<br>/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp: In member function ‘void keyop_core::KeyOpCore::processKeyboardInput(char)’:<br>/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp:293:38: error: ‘KEYCODE_LEFT’ is not a member of ‘kobuki_msgs::KeyboardInput {aka kobuki_msgs::KeyboardInput_}’<br>case kobuki_msgs::KeyboardInput::KEYCODE_LEFT:<br>^</del><br>/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp:298:38: error: ‘KEYCODE_RIGHT’ is not a member of ‘kobuki_msgs::KeyboardInput {aka kobuki_msgs::KeyboardInput_}’<br>case kobuki_msgs::KeyboardInput::KEYCODE_RIGHT:<br>^<del>~<br>/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp:303:38: error: ‘KEYCODE_UP’ is not a member of ‘kobuki_msgs::KeyboardInput {aka kobuki_msgs::KeyboardInput_}’<br>case kobuki_msgs::KeyboardInput::KEYCODE_UP:<br>^</del><br>/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp:308:38: error: ‘KEYCODE_DOWN’ is not a member of ‘kobuki_msgs::KeyboardInput {aka kobuki_msgs::KeyboardInput_}’<br>case kobuki_msgs::KeyboardInput::KEYCODE_DOWN:<br>^<del>~<br>/home/wwh/turtlebot_ws/src/kobuki_keyop/src/keyop_core.cpp:313:38: error: ‘KEYCODE_SPACE’ is not a member of ‘kobuki_msgs::KeyboardInput {aka kobuki_msgs::KeyboardInput_}’<br>case kobuki_msgs::KeyboardInput::KEYCODE_SPACE:<br>^</del><br>kobuki_keyop/src/CMakeFiles/keyop.dir/build.make:62: recipe for target ‘kobuki_keyop/src/CMakeFiles/keyop.dir/keyop_core.cpp.o’ failed</p><p>所需文件：<br><a href="./images/2954616753.zip">pud.zip</a><br>若编译出现错误：   processKeyboardInput(key.pressed_key);<br>     case kobuki_msgs::KeyboardInput::KEYCODE_LEFT:<br>    case kobuki_msgs::KeyboardInput::KEYCODE_RIGHT:<br>     …<br>请用包中的文件替换kobuki_node/src/library/slot_callbacks.cpp和/kobuki_keyop/src/keyop_core.cpp</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS学习（四）----参数与launch</title>
      <link href="/2020/06/25/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%8F%82%E6%95%B0%E4%B8%8Elaunch/"/>
      <url>/2020/06/25/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%8F%82%E6%95%B0%E4%B8%8Elaunch/</url>
      
        <content type="html"><![CDATA[<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>launch是一个xml语法的文件</p><h1 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h1><p>方便启动多个节点，设置参数</p><h1 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h1><ul><li>&lt;launch&gt;<ul><li>&lt;node&gt;</li><li>&lt;param&gt;</li><li>&lt;arg&gt;</li><li>…</li></ul></li></ul><p>xml中缩进没有实际意义，但为了表达清楚各标签间关系，使用缩进。</p><h1 id=""><a href="#" class="headerlink" title=""></a><node></h1><p>demo: 运行”package-name”中”executable-name”的二进制文件，</p><ul><li>ROS中注册节点名为”node-name”（会自动修改ros::init()中的内容）</li></ul><pre><code>&lt;node pkg=&quot;package-name&quot;type=&quot;executable-name&quot; name=&quot;node-name&quot; /&gt;</code></pre><h2 id="其他常用参数"><a href="#其他常用参数" class="headerlink" title="其他常用参数"></a><node>其他常用参数</h2><ul><li><p>output = “screen”：将节点的标准输出打印到终端屏幕，默认输出为日志文档；</p></li><li><p>respawn = “true”：复位属性，该节点停止时，会自动重启，默认为false；</p></li><li><p>required = “true”：必要节点，当该节点终止时，launch文件中的其他节点也被终止；</p></li><li><p>ns = “namespace”：命名空间，为节点内的相对名称添加命名空间前缀；</p></li><li><p>args = “arguments”：节点需要的输入参数。</p></li></ul><h2 id="参数标签"><a href="#参数标签" class="headerlink" title="参数标签"></a>参数标签</h2><ol><li>&lt;param&gt;<br>parameter是ROS系统运行中的参数，存储在参数服务器中。在launch文件中通过<param>元素加载parameter；launch文件执行后，parameter就加载到ROS的参数服务器上了。每个活跃的节点都可以通过 **ros::param::get()**接口来获取parameter的值，用户也可以在终端中通过rosparam命令获得parameter的值。</li></ol><p>&lt;param&gt;的使用方法如下：</p><pre><code>&lt;param name=&quot;output_frame&quot; value=&quot;odom&quot;/&gt;</code></pre><p>运行launch文件后，output_frame这个parameter的值就设置为odom，并且加载到ROS参数服务器上了。但是在很多复杂的系统中，参数的数量很多，如果这样一个一个的设置会非常麻烦，ROS也为我们提供了另外一种类似的参数加载方式——<rosparam>：</p><pre><code>&lt;rosparamfile=&quot;$(find 2dnav_pr2)/config/costmap_common_params.yaml&quot; command=&quot;load&quot; ns=&quot;local_costmap&quot; /&gt;</code></pre><p>&lt;rosparam&gt;可以帮助我们将一个yaml格式文件中的参数全部加载到ROS参数服务器中，需要设置command属性为“load”，还可以选择设置命名空间“ns”。</p><ol start="2"><li><p>&lt;arg&gt;<br>&lt;arg&gt; 为launch文件内部参数。<br>设置argument使用<arg>标签元素，语法如下：</p> <arg name=”arg-name” default=”arg-value”/></li></ol><p>launch文件中需要使用到argument时，可以使用如下方式调用：</p><pre><code>&lt;paramname=&quot;foo&quot; value=&quot;$(arg arg-name)&quot; /&gt;&lt;node name=&quot;node&quot; pkg=&quot;package&quot; type=&quot;type &quot;args=&quot;$(arg arg-name)&quot; /&gt;</code></pre><h2 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h2><ol><li><p>引用其他launch文件（嵌套复用）<br>在复杂的系统当中，launch文件往往有很多，这些launch文件之间也会存在依赖关系。如果需要直接复用一个已有launch文件中的内容，可以使用<include>标签包含其他launch文件，这和C语言中的include几乎是一样的。</p> <include file="$(dirname)/other.launch" /></li></ol><p>总而言之，launch是ROS框架中非常实用、灵活的功能，它类似于一种高级编程语言，可以帮助我们管理启动系统时的方方面面。在使用ROS的过程中，很多情况下我们并不需要编写大量代码，仅需要使用已有的功能包，编辑一下launch文件，就可以完成很多机器人功能。</p><ol start="2"><li>重映射</li></ol><p>ROS的设计目标是提高代码的复用率，所以ROS社区中的很多功能包我们都可以拿来直接使用，而不需要关注功能包的内部实现。那么问题就来了，别人功能包的接口不一定和我们的系统兼容呀？</p><p>ROS提供一种重映射的机制，简单来说就是取别名，类似于C++中的别名机制，我们不需要修改别人功能包的接口，只需要将接口名称重映射一下，取个别名，我们的系统就认识了（接口的数据类型必须相同）。launch文件中的<remap>标签可以帮我们实现这个重映射的功能。</p><p>比如turtlebot的键盘控制节点，发布的速度控制指令话题可能是/turtlebot/cmd_vel，但是我们自己的机器人订阅的速度控制话题是/cmd_vel，这个时候使用<remap>就可以轻松解决问题，将/turtlebot /cmd_vel重映射为/cmd_vel，我们的机器人就可以接收到速度控制指令了：</p><pre><code>&lt;remap from=&quot;/turtlebot/cmd_vel&quot;to=&quot;/cmd_vel&quot;/&gt;</code></pre><p>重映射机制在ROS中的使用非常广泛，也非常重要，方法不止这一种，也可以在终端rosrun命令中实现重映射，大家一定要理解好这种机制。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS学习（三）----action</title>
      <link href="/2020/06/25/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89-action/"/>
      <url>/2020/06/25/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89-action/</url>
      
        <content type="html"><![CDATA[<p>在了解了service与topic这两种较为简单的通信之后，继续学习一种新的交互方式—-action</p><h1 id="文件构成"><a href="#文件构成" class="headerlink" title="文件构成"></a>文件构成</h1><p>action文件以**.action**为后缀，其内容与service相似，多了过程中的反馈（Feedback）</p><pre><code># demo.action# define goalint32 demo_goal---# define resultint[] demo_res---# define feedbackint[] demo_fb</code></pre><h1 id="编译action"><a href="#编译action" class="headerlink" title="编译action"></a>编译action</h1><p>编译action文件为头文件时，</p><p><strong>CMakeList.txt</strong>中需要添加activelib 及 activelib_msgs</p><pre><code>find_package(....generate_message(activelib_msgs...catkin_package(LIBRARIES ...               CATKIN_DEPENDS actionlib actionlib_msgs roscpp std_msgs ...               DEPENDS BOOST               )</code></pre><h1 id="cpp中调用action文件与actionlib"><a href="#cpp中调用action文件与actionlib" class="headerlink" title="cpp中调用action文件与actionlib"></a>cpp中调用action文件与actionlib</h1><pre><code>// 以demo.action为例#include&lt;demoAction.h&gt;//调用actionlib//server端#include&lt;actionlib/simple_action_server.h&gt;//client端#include&lt;actionlib/simple_action_client.h&gt; // action library header files#inclued&lt;actionlib/terminal_state.h&gt; //action_goals status files</code></pre><h1 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h1><ol><li><p>Client<br> // Action Client Declaration (Action Name: ros_tutorial_action)<br>   actionlib::SimpleActionClient&lt;ros_tutorials_action::FibonacciAction&gt; ac(“ros_tutorial_action”, true);<br>//client 端不需要节点句柄， true表示不需要ros::spin();,因此循环等待服务为：</p><p> ac.waitForServer()</p></li><li><p>Server<br>// 句柄需在action_sercer 创建之前被创建<br>ros::NodeHandle nh_;  // Node handle declaration<br>actionlib::SimpleActionServer&lt;ros_tutorials_action::FibonacciAction&gt; as_;</p></li></ol><p>// 初始化as_时，会自动获取client发出action文件中的goal的地址</p><pre><code>public:  // Initialize action server (Node handle, action name, action callback function)  FibonacciAction(std::string name) :    as_(nh_, name, boost::bind(&amp;FibonacciAction::executeCB, this, _1), false),    action_name_(name)  &#123;    as_.start();  &#125;......</code></pre><p><a href="https://www.jianshu.com/p/30e79d2a8f7d">bind绑定函数</a></p><p>关于请求的细节：</p><pre><code>// 确认请求存在且非preempted// Preempted - Processing of the goal was canceled by either another goal, //             or a cancel request sent to the action serverfor(int i=1; i&lt;=goal-&gt;order; i++)    &#123;      // Confirm action cancellation from action client      if (as_.isPreemptRequested() || !ros::ok())      &#123;        // Notify action cancellation        ROS_INFO(&quot;%s: Preempted&quot;, action_name_.c_str());        // Action cancellation and consider action as failure and save to variable        as_.setPreempted();        success = false;        break;      &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS学习（二）----节点（Node）</title>
      <link href="/2020/06/21/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/"/>
      <url>/2020/06/21/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h5 id="重新返回去熟悉操作，加深印象。"><a href="#重新返回去熟悉操作，加深印象。" class="headerlink" title="重新返回去熟悉操作，加深印象。"></a>重新返回去熟悉操作，加深印象。</h5><p>这次将更条理地，细致地梳理遇到的一系列问题。<br><img src="./images/2311292133.png" alt="1592790092(1).png"></p><h1 id="Package-结构"><a href="#Package-结构" class="headerlink" title="Package 结构"></a>Package 结构</h1><ul><li>package<ul><li>src<ul><li>example_node.cpp</li></ul></li><li>…</li><li>package.xml</li><li>CMakList.txt</li></ul></li></ul><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ol><li>${workspace}/src 下使用命令 <code>catkin_create_pkg $&#123;pkg_name&#125; $&#123;dependencis&#125;</code></li><li>进入package(后用pkg代替）编写文件。（cpp || py）</li><li>编辑 <strong>package.xml &amp;&amp; CMakList.txt</strong></li><li><code>catkin_make</code></li></ol><h1 id="流程中的一些细节问题"><a href="#流程中的一些细节问题" class="headerlink" title="流程中的一些细节问题"></a>流程中的一些细节问题</h1><h2 id="2-编写cpp"><a href="#2-编写cpp" class="headerlink" title="2. 编写cpp"></a>2. 编写cpp</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>默认两个参数：    <strong>int argc, char**argv</strong><br>初始化时会用到： <code>ros::init(argc,argv,&quot;node_name&quot;);</code></p><h3 id="回调参数"><a href="#回调参数" class="headerlink" title="回调参数"></a>回调参数</h3><p>ConstPtr&amp; 与 Ptr&amp; 的区别：<br>ConstPtr 常类型msg ，减少传值次数。<br><a href="https://answers.ros.org/question/212857/what-is-constptr/">https://answers.ros.org/question/212857/what-is-constptr/</a></p><h2 id="3-编辑package-xml-amp-amp-CMakeList-txt"><a href="#3-编辑package-xml-amp-amp-CMakeList-txt" class="headerlink" title="3.编辑package.xml &amp;&amp; CMakeList.txt"></a>3.编辑package.xml &amp;&amp; CMakeList.txt</h2><h3 id="使用了msg文件"><a href="#使用了msg文件" class="headerlink" title="使用了msg文件"></a>使用了msg文件</h3><h4 id="由于ROS通过message-generation-对-msg文件编译以及-message-runtime-在节点中运行有关-msg文件。所以需要在package-xml中加入编译依赖及运行依赖"><a href="#由于ROS通过message-generation-对-msg文件编译以及-message-runtime-在节点中运行有关-msg文件。所以需要在package-xml中加入编译依赖及运行依赖" class="headerlink" title="由于ROS通过message_generation 对.msg文件编译以及 message_runtime 在节点中运行有关.msg文件。所以需要在package.xml中加入编译依赖及运行依赖"></a>由于ROS通过message_generation 对.msg文件编译以及 message_runtime 在节点中运行有关.msg文件。所以需要在<strong>package.xml</strong>中加入编译依赖及运行依赖</h4><pre><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt; &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code></pre><h4 id="同时需要修改-CMakeList-txt"><a href="#同时需要修改-CMakeList-txt" class="headerlink" title="同时需要修改 CMakeList.txt"></a>同时需要修改 <strong>CMakeList.txt</strong></h4><h5 id="在catkin-make编译找依赖包的位置，写入”message-generation”"><a href="#在catkin-make编译找依赖包的位置，写入”message-generation”" class="headerlink" title="在catkin_make编译找依赖包的位置，写入”message_generation”"></a>在catkin_make编译找依赖包的位置，写入”message_generation”</h5><pre><code>find_package(catkin REQUIRED COMPONENTS  roscpp  std_msgs  message_generation)</code></pre><h5 id="在添加编译msg的步骤（generate-message-即在devel下生成对应的-demo-h"><a href="#在添加编译msg的步骤（generate-message-即在devel下生成对应的-demo-h" class="headerlink" title="在添加编译msg的步骤（generate_message(), 即在devel下生成对应的  demo.h"></a>在添加编译msg的步骤（generate_message(), 即在devel下生成对应的  <strong>demo.h</strong></h5><pre><code>add_message_files(  FILES  demo.msg)generate_messages(DEPENDENCIES std_msgs)</code></pre><h5 id="添加Node运行时依赖-message-runtime"><a href="#添加Node运行时依赖-message-runtime" class="headerlink" title="添加Node运行时依赖 message_runtime"></a>添加Node运行时依赖 <strong>message_runtime</strong></h5><pre><code>catkin_package( CATKIN_DEPENDS roscpp std_msgs message_runtime)</code></pre><h5 id="若需编译为二进制文件"><a href="#若需编译为二进制文件" class="headerlink" title="若需编译为二进制文件"></a>若需编译为二进制文件</h5><pre><code># 仅为demo， 前两行为 将cpp文件编译为# 添加 二进制文件         二进制文件名    cpp文件位置add_executable(fbnq_subscriber src/topic_subscriber.cpp)# add_executable是对于构建之后要创建的可执行文件的选项。# 二进制文件引用         二进制文件名         对应上面填写的target_link_libraries(fbnq_subscriber $&#123;catkin_LIBRARIES&#125;)# target_link_libraries是在创建特定的可执行文件之前将库和可执行文件进行链接的 选项。 # 添加依赖                    二进制文件名         依赖编译后的messageadd_dependencies(fbnq_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp)# add_dependencies是一个首选项，是在构建库和可执行文件之前创建依赖消息和dynamic reconfigure的设置。</code></pre><h6 id="需要注意俩个add-dependencies添加的依赖是不一样的"><a href="#需要注意俩个add-dependencies添加的依赖是不一样的" class="headerlink" title="需要注意俩个add_dependencies添加的依赖是不一样的"></a>需要注意俩个<strong>add_dependencies</strong>添加的依赖是不一样的</h6><p><img src="./images/1204245160.png" alt="微信截图_20200622093823.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>旧笔记本安装Ubuntu</title>
      <link href="/2020/06/17/%E6%97%A7%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2020/06/17/%E6%97%A7%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol><li>制作安装盘</li><li>安装<h1 id="所需物品"><a href="#所需物品" class="headerlink" title="所需物品"></a>所需物品</h1></li><li>8G以上 U盘</li><li>一台旧笔记本</li></ol><h1>制作安装盘</h1>## pre:下载镜像: [点击链接][1]使用uiso9_pe烧录到U盘：1. [点击下载][2]2. 选择好镜像文件后，选择**“写入硬盘映像”**<h1>安装</h1>1. 插入U盘，修改BIOS2. 按引导一步一步进行，全部清除原分区3. 等待]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux--端口</title>
      <link href="/2020/06/16/Linux-%E7%AB%AF%E5%8F%A3/"/>
      <url>/2020/06/16/Linux-%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Cause"><a href="#Cause" class="headerlink" title="Cause"></a>Cause</h2><p>经常使用端口服务，同时可能非法退出，所以整理一下有关端口占用及解除的命令。</p><h3 id="查看占用"><a href="#查看占用" class="headerlink" title="查看占用"></a>查看占用</h3><pre><code>netstat -anl | grep &quot;80&quot;# 或者lsof -i:80</code></pre><h3 id="解除占用"><a href="#解除占用" class="headerlink" title="解除占用"></a>解除占用</h3><pre><code>kill -9 pid or name  # 通过pid或进程名杀掉，-9表示显示执行结果# 相关命令 killallkillall apt apt-get  # 结束所有 apt apt-get 进程</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS基本学习（一）</title>
      <link href="/2020/06/11/ROS%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/06/11/ROS%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>（看手册看的我迷迷糊糊~</p><h2 id="简单工作构成介绍"><a href="#简单工作构成介绍" class="headerlink" title="简单工作构成介绍"></a>简单工作构成介绍</h2><p>ROS是一个多节点的分布式工作平台，节点之间，当然就会有数据的收发。ROS中通过主节点来将各个分布的节点的数据记录，方便节点间相互联络。ROS运行的最小单位Node。</p><h3 id="Node的工作方式"><a href="#Node的工作方式" class="headerlink" title="Node的工作方式"></a>Node的工作方式</h3><ol><li>Topic<br> 特点：publisher发布，subscriber接收（异步完成）</li><li>Service<br> 特点：client直连server，直至会话结束</li></ol><ul><li>Package<ul><li>node<ul><li>subscriber</li><li>publisher</li><li>server</li><li>client</li><li>…</li></ul></li></ul></li></ul><h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><h3 id="Catkin"><a href="#Catkin" class="headerlink" title="Catkin"></a>Catkin</h3><pre><code>ROS提供了较为友好构建包的过程。</code></pre><ol><li>在工作空间(workspace)下执行：<br> catkin_create_pkg ${your_package_name} ${dependent_packages}</li><li>对应文件夹下，写好文件例如(demo.cpp),之后再修改<strong>CMakeList.txt</strong>中对应参数，及依赖。</li></ol><p>示例文件:</p><pre><code>cmake_minimum_required(VERSION 2.8.3)project(learning_launch)## Compile as C++11, supported in ROS Kinetic and newer# add_compile_options(-std=c++11)## Find catkin macros and libraries## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)## is used, also find other catkin packagesfind_package(catkin REQUIRED)## System dependencies are found with CMake&#39;s conventions# find_package(Boost REQUIRED COMPONENTS system)## Uncomment this if the package has a setup.py. This macro ensures## modules and global scripts declared therein get installed## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html# catkin_python_setup()################################################## Declare ROS messages, services and actions #################################################################################################### 声明 ROS 消息 服务 动作 的相关文件           #################################################### To declare and build messages, services or actions from within this## package, follow these steps:## * Let MSG_DEP_SET be the set of packages whose message types you use in##   your messages/services/actions (e.g. std_msgs, actionlib_msgs, ...).## * In the file package.xml:##   * add a build_depend tag for &quot;message_generation&quot;##   * add a build_depend and a exec_depend tag for each package in MSG_DEP_SET##   * If MSG_DEP_SET isn&#39;t empty the following dependency has been pulled in##     but can be declared for certainty nonetheless:##     * add a exec_depend tag for &quot;message_runtime&quot;## * In this file (CMakeLists.txt):##   * add &quot;message_generation&quot; and every package in MSG_DEP_SET to##     find_package(catkin REQUIRED COMPONENTS ...)##   * add &quot;message_runtime&quot; and every package in MSG_DEP_SET to##     catkin_package(CATKIN_DEPENDS ...)##   * uncomment the add_*_files sections below as needed##     and list every .msg/.srv/.action file to be processed##   * uncomment the generate_messages entry below##   * add every package in MSG_DEP_SET to generate_messages(DEPENDENCIES ...)## Generate messages in the &#39;msg&#39; folder# add_message_files(#   FILES#   Message1.msg#   Message2.msg# )## Generate services in the &#39;srv&#39; folder# add_service_files(#   FILES#   Service1.srv#   Service2.srv# )## Generate actions in the &#39;action&#39; folder# add_action_files(#   FILES#   Action1.action#   Action2.action# )## Generate added messages and services with any dependencies listed here# generate_messages(#   DEPENDENCIES#   std_msgs  # Or other packages containing msgs# )################################################## Declare ROS dynamic reconfigure parameters #################################################### To declare and build dynamic reconfigure parameters within this## package, follow these steps:## * In the file package.xml:##   * add a build_depend and a exec_depend tag for &quot;dynamic_reconfigure&quot;## * In this file (CMakeLists.txt):##   * add &quot;dynamic_reconfigure&quot; to##     find_package(catkin REQUIRED COMPONENTS ...)##   * uncomment the &quot;generate_dynamic_reconfigure_options&quot; section below##     and list every .cfg file to be processed## Generate dynamic reconfigure parameters in the &#39;cfg&#39; folder# generate_dynamic_reconfigure_options(#   cfg/DynReconf1.cfg#   cfg/DynReconf2.cfg# )##################################### catkin specific configuration ####################################### The catkin_package macro generates cmake config files for your package## Declare things to be passed to dependent projects## INCLUDE_DIRS: uncomment this if your package contains header files## LIBRARIES: libraries you create in this project that dependent projects also need## CATKIN_DEPENDS: catkin_packages dependent projects also need## DEPENDS: system dependencies of this project that dependent projects also needcatkin_package(#  INCLUDE_DIRS include#  LIBRARIES learning_launch#  CATKIN_DEPENDS other_catkin_pkg#  DEPENDS system_lib)############# Build ############### Specify additional locations of header files## Your package locations should be listed before other locationsinclude_directories(# include# $&#123;catkin_INCLUDE_DIRS&#125;)## Declare a C++ library# add_library($&#123;PROJECT_NAME&#125;#   src/$&#123;PROJECT_NAME&#125;/learning_launch.cpp# )## Add cmake target dependencies of the library## as an example, code may need to be generated before libraries## either from message generation or dynamic reconfigure# add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)## Declare a C++ executable## 声明一个C++可执行文件## With catkin_make all packages are built within a single CMake context## The recommended prefix ensures that target names across packages don&#39;t collide# add_executable($&#123;PROJECT_NAME&#125;_node src/learning_launch_node.cpp)## Rename C++ executable without prefix## The above recommended prefix causes long target names, the following renames the## target back to the shorter version for ease of user use## e.g. &quot;rosrun someones_pkg node&quot; instead of &quot;rosrun someones_pkg someones_pkg_node&quot;# set_target_properties($&#123;PROJECT_NAME&#125;_node PROPERTIES OUTPUT_NAME node PREFIX &quot;&quot;)## Add cmake target dependencies of the executable## 添加cmake生成可执行文件的依赖## same as for the library above# add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)## Specify libraries to link a library or executable target against# target_link_libraries($&#123;PROJECT_NAME&#125;_node#   $&#123;catkin_LIBRARIES&#125;# )############### Install ################ all install targets should use catkin DESTINATION variables# See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html## Mark executable scripts (Python etc.) for installation## in contrast to setup.py, you can choose the destination# install(PROGRAMS#   scripts/my_python_script#   DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;# )## Mark executables and/or libraries for installation# install(TARGETS $&#123;PROJECT_NAME&#125; $&#123;PROJECT_NAME&#125;_node#   ARCHIVE DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;#   LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;#   RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;# )## Mark cpp header files for installation# install(DIRECTORY include/$&#123;PROJECT_NAME&#125;/#   DESTINATION $&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;#   FILES_MATCHING PATTERN &quot;*.h&quot;#   PATTERN &quot;.svn&quot; EXCLUDE# )## Mark other files for installation (e.g. launch and bag files, etc.)# install(FILES#   # myfile1#   # myfile2#   DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;# )############### Testing ################# Add gtest based cpp test target and link libraries# catkin_add_gtest($&#123;PROJECT_NAME&#125;-test test/test_learning_launch.cpp)# if(TARGET $&#123;PROJECT_NAME&#125;-test)#   target_link_libraries($&#123;PROJECT_NAME&#125;-test $&#123;PROJECT_NAME&#125;)# endif()## Add folders to be run by python nosetests# catkin_add_nosetests(test)</code></pre><ol start="3"><li>编译</li></ol><pre><code>cd $&#123;work_space&#125; # 通常为catkin_wscatkin_make # 自动编译未被编译的package</code></pre><ol start="4"><li>添加环境变量</li></ol><pre><code># catkin_ws下source devel/setup.bash</code></pre><p>或者在~目录下设置好自动添加(之后不需要执行第四步）</p><pre><code># ~sudo nano .bashrc# 文件末添加# source /home/&#123;user_name&#125;/&#123;workspace&#125;/devel/setup.bash</code></pre><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>脑图总结</p><p><a href="./images/2190550263.xmind">ROS learning.xmind</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爬取微博并将最新一条推送至微信</title>
      <link href="/2020/05/21/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E5%B9%B6%E5%B0%86%E6%9C%80%E6%96%B0%E4%B8%80%E6%9D%A1%E6%8E%A8%E9%80%81%E8%87%B3%E5%BE%AE%E4%BF%A1/"/>
      <url>/2020/05/21/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E5%B9%B6%E5%B0%86%E6%9C%80%E6%96%B0%E4%B8%80%E6%9D%A1%E6%8E%A8%E9%80%81%E8%87%B3%E5%BE%AE%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>首先感谢<a href="https://github.com/dataabc/">dataabc</a>所写的weibo-scrawler项目，非常感谢能够开源。</p><ul><li>部署</li><li>调参<ul><li>config.json</li><li>msg.py</li></ul></li><li>使用</li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="clone-项目"><a href="#clone-项目" class="headerlink" title="clone 项目"></a>clone 项目</h2><pre><code>git clone https://github.com/Ermaotie/weibo-crawler.git</code></pre><h2 id="安装相关module"><a href="#安装相关module" class="headerlink" title="安装相关module"></a>安装相关module</h2><pre><code>pip install -r requirement.txt</code></pre><h1 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h1><h2 id="config-json"><a href="#config-json" class="headerlink" title="config.json"></a>config.json</h2><p>详细设置见<a href="https://github.com/Ermaotie/weibo-crawler">github</a><br>这里必须将文件格式保存为json<br>若想要定期执行，请将<code>since_date</code>设置为 <strong>int</strong> 型整数</p><h2 id="msg-py"><a href="#msg-py" class="headerlink" title="msg.py"></a>msg.py</h2><ol><li>方糖server酱绑定微信并获取SCKEY</li><li>填入SCKEY，修改文件路径为 </li></ol><pre><code>weibo/微博用户名/微博id.json</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="使用crontab-定期执行"><a href="#使用crontab-定期执行" class="headerlink" title="使用crontab 定期执行"></a>使用crontab 定期执行</h2><pre><code>crontab -e# 编辑定时执行任务0 12 * * * python weibo.py # 绝对路径0 12 * * * python msg.py # 绝对路径# 每天12时0分 执行xxx# 注意python版本</code></pre><h2 id="crontab-命令format"><a href="#crontab-命令format" class="headerlink" title="crontab 命令format"></a>crontab 命令format</h2><pre><code>*    *    *    *    *    your command-    -    -    -    -|    |    |    |    ||    |    |    |    +----- 星期中星期几 (0 - 7) (星期天 为0)|    |    |    +---------- 月份 (1 - 12) |    |    +--------------- 一个月中的第几天 (1 - 31)|    +-------------------- 小时 (0 - 23)+------------------------- 分钟 (0 - 59)</code></pre><h2 id="查看任务列表"><a href="#查看任务列表" class="headerlink" title="查看任务列表"></a>查看任务列表</h2><pre><code>crontab -l</code></pre><h3 id="To-Do-将msg写入weibo-py中"><a href="#To-Do-将msg写入weibo-py中" class="headerlink" title="To Do: 将msg写入weibo.py中"></a>To Do: 将msg写入weibo.py中</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>float在计算机中的存储</title>
      <link href="/2020/05/12/float%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2020/05/12/float%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>在了解float之前，先来复习一下int的存储方式</p><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul><li>原码</li><li>补码</li><li>反码<br>以在32的计算机系统中为例，<br>一个int占四个字节，也就是32位<br>第一位表示正负(0正1负），后面三十一位表示数。<br>因此，int的范围是 $-2^{32}$(100000…000) 到 $2^{32}-1$(01111…11111)<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2></li><li>组成<ul><li>正负 第一位</li><li>数位 往后八位</li><li>数值 余下23位</li></ul></li></ul><p>float可以看作是二进制的科学计数法，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.25</span><br><span class="line">#采用二进制表示</span><br><span class="line">1010.01</span><br><span class="line">1.01001*2**3</span><br></pre></td></tr></table></figure><p>接下来会以这个例子作为介绍。</p><h3 id="正负-0正1负"><a href="#正负-0正1负" class="headerlink" title="正负 0正1负"></a>正负 0正1负</h3><h3 id="数位-采取“平移”的思想来理解"><a href="#数位-采取“平移”的思想来理解" class="headerlink" title="数位 采取“平移”的思想来理解"></a>数位 采取“平移”的思想来理解</h3><p>八位二进制数均为正可表达的数的范围是0~2**9-1，我们以127为界限，也就是将127看作0，划分正负，即将指数部分划为正负两部分。</p><pre><code># 1.01001*2**3# 指数为3# 127+3=130# 130 = 2**7+2**1# 数位区应写为# 01000010</code></pre><h3 id="数值，小数部分"><a href="#数值，小数部分" class="headerlink" title="数值，小数部分"></a>数值，小数部分</h3><p>因为第一位数基本上(有例外)都是一，所以我们省去。</p><pre><code># 1.01001*2**3# 省去变为 01001，则后面的数位由0补齐。</code></pre><p>最终表达为<br>0 01000010 010010000…000<br>再来一个例子</p><pre><code># 0.5# 0 01111110 100000...00</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装并使用v2ray客户端</title>
      <link href="/2020/05/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8v2ray%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2020/05/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8v2ray%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用v2ray也有一两年的时间了，用的挺舒服添加订阅就完事儿了，也没有心思去深挖一下为什么我用的是V2rayN？还要下载内核？恰好这几天折腾树莓派，想用走一下代理，结果并没有想的那么直接。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>调整v2ray的config.json<ul><li>写好inbounds &amp; outbounds</li></ul></li><li>使用proxychains4<ul><li>下载安装</li><li>配置代理</li><li>实现命令</li></ul></li></ul><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><pre><code>git clone https://github.com/rofl0r/proxychains-ng.gitsudo su - root# 到下载目录编译安装./configuremake &amp;&amp; make install</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code>cp ./src/proxychains.conf /etc/proxychains.confvim /etc/proxychains.conf# 将最后的 socks4 127.0.0.1 9095 改为 socks5  127.0.0.1 1080(与v2ray 对应即可）exit # 退出root用户</code></pre><h4 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h4><p>想通过代理的命令前加<strong>proxychains4</strong></p><pre><code>proxychains4 curl ip.sb</code></pre><h2 id="浅入了解"><a href="#浅入了解" class="headerlink" title="浅入了解"></a>浅入了解</h2><p>v2rayN其实就像是博客的主题，让BLOG变得平易近人，好看又方便。真正实现功能的是v2ray-core。</p><h3 id="v2ray-core"><a href="#v2ray-core" class="headerlink" title="v2ray-core"></a>v2ray-core</h3><p>从config.json入手，我们来看看v2ray-core运行。</p><pre><code># config.json&#123;  &quot;log&quot;: &#123;    &quot;access&quot;: &quot;&quot;,    &quot;error&quot;: &quot;&quot;,    &quot;loglevel&quot;: &quot;warning&quot;  &#125;,  &quot;inbounds&quot;: [    &#123;      &quot;port&quot;: 10808,      &quot;listen&quot;: &quot;0.0.0.0&quot;,      &quot;protocol&quot;: &quot;socks&quot;,      &quot;sniffing&quot;: &#123;        &quot;enabled&quot;: true,        &quot;destOverride&quot;: [          &quot;http&quot;,          &quot;tls&quot;        ]      &#125;,      &quot;settings&quot;: &#123;        &quot;auth&quot;: &quot;noauth&quot;,        &quot;udp&quot;: true,        &quot;ip&quot;: null,        &quot;clients&quot;: [      &#123;        &quot;id&quot;: &quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;,  // 用户 ID，客户端与服务器必须相同        &quot;alterId&quot;: 64      &#125;    ]      &#125;,      &quot;streamSettings&quot;: null    &#125;  ],  &quot;outbounds&quot;: [    &#123;      &quot;tag&quot;: &quot;proxy&quot;,      &quot;protocol&quot;: &quot;vmess&quot;,      &quot;settings&quot;: &#123;        &quot;vnext&quot;: [          &#123;            &quot;address&quot;: &quot;google.com&quot;,            &quot;port&quot;: 80,            &quot;users&quot;: [              &#123;                &quot;id&quot;: &quot;749bf9f9-3423-3666-86ef-87e9b9e2a332&quot;,                &quot;alterId&quot;: 0,                &quot;email&quot;: &quot;t@t.tt&quot;,                &quot;security&quot;: &quot;auto&quot;              &#125;            ]          &#125;        ],        &quot;servers&quot;: null,        &quot;response&quot;: null      &#125;,      &quot;streamSettings&quot;: &#123;        &quot;network&quot;: &quot;ws&quot;,        &quot;security&quot;: &quot;&quot;,        &quot;tlsSettings&quot;: &#123;          &quot;allowInsecure&quot;: true,          &quot;serverName&quot;: &quot;d6a5e4d7238acfab4dd366754a9bd95a.wuyiauto.com&quot;        &#125;,        &quot;tcpSettings&quot;: null,        &quot;kcpSettings&quot;: null,        &quot;wsSettings&quot;: &#123;          &quot;connectionReuse&quot;: true,          &quot;path&quot;: &quot;/user&quot;,          &quot;headers&quot;: &#123;            &quot;Host&quot;: &quot;d6a5e4d7238acfab4dd366754a9bd95a.wuyiauto.com&quot;          &#125;        &#125;,        &quot;httpSettings&quot;: null,        &quot;quicSettings&quot;: null      &#125;,      &quot;mux&quot;: &#123;        &quot;enabled&quot;: true      &#125;    &#125;,    &#123;      &quot;tag&quot;: &quot;direct&quot;,      &quot;protocol&quot;: &quot;freedom&quot;,      &quot;settings&quot;: &#123;        &quot;vnext&quot;: null,        &quot;servers&quot;: null,        &quot;response&quot;: null      &#125;,      &quot;streamSettings&quot;: null,      &quot;mux&quot;: null    &#125;,    &#123;      &quot;tag&quot;: &quot;block&quot;,      &quot;protocol&quot;: &quot;blackhole&quot;,      &quot;settings&quot;: &#123;        &quot;vnext&quot;: null,        &quot;servers&quot;: null,        &quot;response&quot;: &#123;          &quot;type&quot;: &quot;http&quot;        &#125;      &#125;,      &quot;streamSettings&quot;: null,      &quot;mux&quot;: null    &#125;  ],  &quot;dns&quot;: null,  &quot;routing&quot;: &#123;    &quot;domainStrategy&quot;: &quot;IPIfNonMatch&quot;,    &quot;rules&quot;: []  &#125;&#125;</code></pre><p>v2ray-core可调参数真的是太灵活了，简单看几个主要的叭~</p><h3 id="inbounds-and-outbounds"><a href="#inbounds-and-outbounds" class="headerlink" title="inbounds and outbounds"></a>inbounds and outbounds</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>简单来说就是“出界”和“入界”。在v2ray中，其实并没有client与server的严格划分。它既可以做服务端，也可以是客户端，有点类似与节点（Node)。<strong>inbound</strong>是如何与上一节点连接，<strong>outbound</strong>是如何与下一节点连接。对于第一个节点，inbound与“浏览器”相连，也就是本地代理，对于最后一个节点，<strong>outbound</strong>与目标网站相连。所有相连的这些桥就是<strong>inbounds</strong>和<strong>outbounds</strong>。</p><pre><code># inbounds&quot;port&quot;: 10808, #端口&quot;listen&quot;: &quot;0.0.0.0&quot;, #监听地址&quot;protocol&quot;: &quot;socks&quot;, # socks协议，浏览器向服务器端发出的数据包被打包成socks。&quot;client&quot;: [          &#123;            &quot;id&quot;: &quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;,  // 用户 ID，客户端与服务器必须相同            &quot;alterId&quot;: 64          &#125;        ]</code></pre><p>打包成socks后，v2ray收到用预设id加密打包为vmess协议的包。再根据<strong>outbounds</strong>中的参数进行发送。</p><pre><code># outbounds&quot;outbounds&quot;: [            &#123;              &quot;tag&quot;: &quot;proxy&quot;,              &quot;protocol&quot;: &quot;vmess&quot;, # 可以看到协议变成了vmess              &quot;settings&quot;: &#123;                &quot;vnext&quot;: [                  &#123;                    &quot;address&quot;: &quot;google.com&quot;, # 下一节点地址                    &quot;port&quot;: 80, # 端口                    &quot;users&quot;: [                      &#123;                        &quot;id&quot;: &quot;749bf9f9-3423-3666-86ef-87e9b9e2a332&quot;,                        &quot;alterId&quot;: 0,                        &quot;email&quot;: &quot;t@t.tt&quot;,                        &quot;security&quot;: &quot;auto&quot;                      &#125;                    ]                  &#125;                ]</code></pre><p>下一节点对上一节点发来的vmess包利用预存的client的id进行解密，解完之后会校验时间，时间一致就会将数据包继续加密成vmess包，转发到下一节点。直至到达目标网站。<br>最后一个节点的outbounds.portocol是freedom，理解为直连叭。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown轻量标记语言学习</title>
      <link href="/2020/05/07/MarkDown%E8%BD%BB%E9%87%8F%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/05/07/MarkDown%E8%BD%BB%E9%87%8F%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="编辑器：Typora"><a href="#编辑器：Typora" class="headerlink" title="编辑器：Typora"></a>编辑器：Typora</h3><p>事实上，Typecho编辑器也默认支持Markdown</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>语法较为简单且能够直接使用部分html标签，怪不得被众人称之为轻量呢~</p><ul><li>标题<ul><li>推荐使用  # 几个# 就表示几级标题</li></ul></li><li>段落<ul><li>换行：末尾添加两个空格，然后回车</li><li>斜体： *斜体文本*     <em>斜体文本</em></li><li>粗体： **粗体文本**          <strong>粗体文本</strong></li><li>斜体： ***粗斜体文本***      <strong><em>粗斜体文本</em></strong><ul><li>字体中* 均可以用_来代替</li></ul></li><li>删除线：<del>删除线</del>  使用~~在文字两边</li><li>下划线： <u>underline</u> 使用html中的u标签</li><li>脚注： 1b.mk[^Come here and drink a bottle of milk！]</li><li>分隔线 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">----------</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li>区块： &gt;<blockquote><p>这是一个区块</p></blockquote></li><li>代码区块： 四个空格或一个制表符或 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\\&#96;&#96;&#96;javascript(可不填)</span><br><span class="line">\\代码区域</span><br><span class="line">\\&#96;&#96;&#96;</span><br><span class="line">忽略\\</span><br></pre></td></tr></table></figure></li><li>链接： <a href="https://1b.mk/">Demo</a><ul><li>[Demo2][1]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Demo](https:1b.mk)</span><br><span class="line">[Demo2][1]</span><br><span class="line">[1]: https:&#x2F;&#x2F;1b.mk</span><br></pre></td></tr></table></figure></li></ul></li><li>图片 同 “链接”</li><li>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</li></ul><p>基本用法到此处结束~<br>PS:由于该主题对一些语法的展示进行了美化，一些效果会有出入。<br>[^Come here and drink a bottle of milk!]: 来喝一瓶牛奶!!<br>[1]: <a href="https://1b.mk/">https://1b.mk</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git命令学习</title>
      <link href="/2020/05/02/Git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/05/02/Git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="./images/403841589.jpg" alt="(1).jpg"></p><h2 id="仓库结构："><a href="#仓库结构：" class="headerlink" title="仓库结构："></a>仓库结构：</h2><p><img src="./images/2772529628.jpg" alt="1588409468(1).jpg"></p><h2 id="基础操作："><a href="#基础操作：" class="headerlink" title="基础操作："></a>基础操作：</h2><p><img src="./images/2137430414.jpg" alt="1588409521(1).jpg"></p><h2 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h2><p><img src="./images/896156408.jpg" alt="1588409858(1).jpg"></p><p>多人协作情况下的细节：</p><p>为了减少冲突的产生，可以先将master <strong>merge</strong> 到自己的分支，之后再merge 到master</p><p><a href="./images/364696890.pdf">导图下载</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS安装跳坑指南</title>
      <link href="/2020/05/02/ROS%E5%AE%89%E8%A3%85%E8%B7%B3%E5%9D%91%E6%8C%87%E5%8D%97/"/>
      <url>/2020/05/02/ROS%E5%AE%89%E8%A3%85%E8%B7%B3%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="官方Kinetic版安装链接：http-wiki-ros-org-cn-kinetic-Installation-Ubuntu"><a href="#官方Kinetic版安装链接：http-wiki-ros-org-cn-kinetic-Installation-Ubuntu" class="headerlink" title="官方Kinetic版安装链接：http://wiki.ros.org/cn/kinetic/Installation/Ubuntu"></a>官方Kinetic版安装链接：<a href="http://wiki.ros.org/cn/kinetic/Installation/Ubuntu">http://wiki.ros.org/cn/kinetic/Installation/Ubuntu</a></h1><p>国内安装真的是太不友好了！！！！！！</p><hr><h2 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h2><p>1.安装包下载太慢</p><p>更换清华镜像源及软件源<br>镜像源列表：<br><a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><p>重写地址： </p><pre><code>/etc/apt/sources.list</code></pre><p>软件源:   </p><pre><code>sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></pre><p>2.ros版本不一致<br>查看方法：</p><pre><code>rosdep --versionapt-cache policy python-rosdep</code></pre><p>版本若不同：<br>需卸载通过pip安装的版本，通过apt安装</p><pre><code>sudo apt-get remove --purge python-rosdep python-pipsudo apt-get updatesudo apt-get install python-rosdep</code></pre><p>3.所有的timeout<br>S：<br>①更改NS服务<br>  所在目录：<code>/etc/resolv.conf</code><br>  推荐更换为谷歌DNS</p><pre><code>nameserver 8.8.8.8nameserver 8.8.4.4</code></pre><p>需要注意的是，ns设置将在每次重新启动后刷新</p><p>②直接将域名所指向的IP设为静态(推荐)<br>  首先到<a href="https://ipaddress.com/">ipaddress.com</a>查找需要设置为静态的域名</p><pre><code>raw.githubusercontent.comgithub.comgithub.global.ssl.fastly.netcodeload.github.com</code></pre><p>  以ip在前，域名在后的形式写入</p><pre><code>/etc/hosts</code></pre><p>例：</p><pre><code>199.232.68.133    raw.githubusercontent.com</code></pre><p>(安装完成后记得将新写入的静态解析擦除，因为GITHUB服务器的IP会更换）</p><p>③使用代理服务<br>  通过shadowsocks或者V2ray，在ubuntu上可能会更加难以操控，如果你了解如何使用，那么这个办法是最省事的，请到<a href="http://www.v2ray.com/">v2ray主页</a>查看如何使用。当然也有一个不太成熟的类似V2rayN式GUI界面的软件——<a href="https://github.com/jiangxufeng/v2rayL">v2rayL</a>(需要设置http以及socket端口转发）</p><p>④安装在哪里？<br>  不推荐安装在虚拟机以及树莓派中，但依然是可以安装的。</p><pre><code>为什么？运行前需要编译很多相关文件</code></pre><p>  Ubuntu 16是最适合装Kinetic的版本<br>关于树莓派3/3+/4安装：<br>直接烧好已经安装好ROS Kinetic的镜像：<a href="https://downloads.ubiquityrobotics.com/pi.html">点击进入</a></p><p>目前遇到坑就这么多了。相关问题详见：<br>孤峰乔木：<a href="https://mp.weixin.qq.com/s?__biz=MzAwNTg5NzUyOA==&mid=2247483943&idx=1&sn=3ad640fd41b2d661ec6f18437219098c&chksm=9b14ee70ac6367661c84490b0e4e98a351e5b05ef65351cca6aceae9adb0caacb7f39a30262e&mpshare=1&scene=1&srcid=0502thJjcK5N6ELd8Ua8wpXy&sharer_sharetime=1588382530879&sharer_shareid=b06e24e740e1d94e6298702d6950f001&key=caf03409094d441c5e7510adb2045afcd862781d483efe22cc617aea57bdf942684599fd07e2140a7829bbf97fa5a7be40543e982acd619505d2a796a27212ecfbb714a4bb1005ab6c17b6aae925654f&ascene=1&uin=MTkwNDAxMTU3OQ==&devicetype=Windows%2010%20x64&version=62090070&lang=zh_CN&exportkey=AzdT3dUghxveKf0UOF5fHoM=&pass_ticket=m9hSQuzboCOWFuzOJube+MaAL74fPQUHB60b7W07TpGfqnF3xXpsaNjkwSfgQvFP">rosdep问题解决</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>轻量博客搭建（tcpsc)</title>
      <link href="/2020/04/08/%E8%BD%BB%E9%87%8F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA(tcpsc)/"/>
      <url>/2020/04/08/%E8%BD%BB%E9%87%8F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA(tcpsc)/</url>
      
        <content type="html"><![CDATA[<h2 id="typecho-caddy-php7-sqlite3-cloudflare"><a href="#typecho-caddy-php7-sqlite3-cloudflare" class="headerlink" title="typecho+caddy+php7+sqlite3+cloudflare"></a><strong>typecho+caddy+php7+sqlite3+cloudflare</strong></h2><p>系统Debian10：<br>执行相应的更新操作,以及安装必要的依赖</p><pre><code>apt updateapt install lsb-releaseapt install net-tools</code></pre><p>优化打开文件的限制次数，默认的打开文件数是1024：</p><pre><code>echo &#39;* soft nofile 51200* hard nofile 51200&#39; &gt;&gt; /etc/security/limits.confulimit -n 51200echo &#39;fs.file-max = 51200net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = hybla&#39; &gt;&gt; /etc/sysctl.confsysctl -p</code></pre><p>更新php7.2的软件源</p><pre><code>#添加GPGwget -O /etc/apt/trusted.gpg.d/php.gpg https://mirror.xtom.com.hk/sury/php/apt.gpg#安装apt-transport-httpsapt-get install apt-transport-https#添加sury软件源sh -c &#39;echo &quot;deb https://packages.sury.org/php/ $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/php.list&#39;#更新软件源缓存apt-get update</code></pre><p>安装php 7.2</p><pre><code>apt install php7.2-fpm php7.2-mysql php7.2-curl php7.2-gd php7.2-mbstring php7.2-xml php7.2-xmlrpc php7.2-zip php7.2-opcache -y</code></pre><p>设置php</p><pre><code>sed -i &#39;s/;cgi.fix_pathinfo=1/cgi.fix_pathinfo=0/&#39; /etc/php/7.2/fpm/php.ini </code></pre><p>php更多命令：</p><pre><code>systemctl restart php7.2-fpm  #重启systemctl start php7.2-fpm  #启动systemctl stop php7.2-fpm  #关闭systemctl status php7.2-fpm  #检查状态</code></pre><hr><p>安装sqlite3</p><pre><code>apt install php7.2-sqlite3#创建数据库文件mkdir /www/db #示例cd /www/dbsqlite3 testDB.db#创建以后权限加满，可读写chmod -R 777 /www/db</code></pre><hr><p>安装caddy：</p><pre><code>#下载并解压Caddywget &quot;https://caddyserver.com/download/linux/amd64?license=personal&amp;telemetry=off&quot; -O - | tar -xzv#新建并写入Caddyfile，目录最好放在Caddy下https://yourdomain.com &#123;    root /www/web/bulid    tls self_signed    fastcgi / /run/php/php7.2-fpm.sock php &#123;         ext .php        split .php        index index.php   &#125;   proxy /hello 127.0.0.1:10000 &#123;      websocket      header_upstream -Origin    &#125;   rewrite &#123;        if &#123;path&#125; not_match ^\/admin        to &#123;path&#125; &#123;path&#125;/ /index.php?&#123;query&#125;    &#125;&#125;</code></pre><p>使用自签名证书，<strong>cloudflare的Catch需要设置Full模式。</strong></p><p>启动Caddy：</p><pre><code>./caddy &gt; caddy.log 2&gt;&amp;1 &amp;</code></pre><p>相关命令：</p><pre><code>启动：systemctl start caddy停止：systemctl stop caddy重启：systemctl restart caddy</code></pre><hr><p>安装typecho：</p><pre><code>#下载wget --no-check-certificate https://github.com/typecho/typecho/releases/download/v1.1-17.10.30-release/1.1.17.10.30.-release.tar.gz -O typecho.tar.gztar -zxvf typecho.tar.gz -C  /www/web#使用本Blog模板wget --no-check-certificate  https://github.com/Zisbusy/Akina-for-Typecho/archive/v3.0.zipmv /Akina-for-Typecho-3.0/Akina/*  /www/web/build/usr/themes/Akina</code></pre><h2 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a><strong>大功告成！</strong></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssh连接树莓派&amp;xrdp远程连接</title>
      <link href="/2020/04/08/ssh%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE-xrdp%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/2020/04/08/ssh%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE-xrdp%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>买回来一块树莓派裸板，没想到ssh连接花了这么长时间。</p><p>首先是在写入系统时需要创建一个名为ssh的文件夹。16年之后的版本都需要这样。因为默认的ssh的关闭的。<br>之后是利用一根网线，直接接到猫的网口，再用<strong>Advanced IP Scanner</strong>扫描找到raspberry的IP地址。</p><h2 id="ssh连接："><a href="#ssh连接：" class="headerlink" title="ssh连接："></a>ssh连接：</h2><pre><code>username：pipassword：raspberry</code></pre><h2 id="连接Wifi："><a href="#连接Wifi：" class="headerlink" title="连接Wifi："></a>连接Wifi：</h2><pre><code>sudo raspi-config</code></pre><p>2 Network Options<br>然后回车，输入SSID，password。</p><pre><code>sudo reboot</code></pre><p>重启自动链接。</p><h2 id="改为静态IP："><a href="#改为静态IP：" class="headerlink" title="改为静态IP："></a>改为静态IP：</h2><p>（否则每次重启后连接都得先找地址）</p><pre><code>sudo nano /etc/dhcpcd.conf</code></pre><p>在文件末加入</p><pre><code>interface eth0# 指定静态IP，/24表示子网掩码为 255.255.255.0static ip_address=192.168.1.20/24# 路由器/网关IP地址static routers=192.168.1.1# 手动自定义DNS服务器static domain_name_servers=114.114.114.114</code></pre><p>WiFi则将第一行改为：</p><pre><code>interface wlan0</code></pre><p>重启生效：</p><pre><code>sudo reboot</code></pre><h2 id="安装xrdp："><a href="#安装xrdp：" class="headerlink" title="安装xrdp："></a>安装xrdp：</h2><p>首先更改软件源：</p><pre><code>sudo vi /etc/apt/sources.list</code></pre><p>更新：</p><pre><code>sudo apt-get upgrade</code></pre><p>安装xrdp：</p><pre><code>sudo apt-get install xrdp</code></pre><p>安装完成后即可通过win10自带的远程桌面连接。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ipv6服务器访问ipv4</title>
      <link href="/2020/04/02/ipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BF%E9%97%AEipv4/"/>
      <url>/2020/04/02/ipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BF%E9%97%AEipv4/</url>
      
        <content type="html"><![CDATA[<p>首先编辑DNS，改为DNS64地址：</p><pre><code>sudo vi /etc/resolv.confnameserver 2001:67c:2b0::4nameserver 2001:67c:27e4::64</code></pre><p>然后编辑/etc/yum/pluginconf.d/fastestmirror.conf，改一下</p><pre><code>enable=0</code></pre><p>更新软件源：</p><pre><code>sudo vi /etc/apt/sources.list</code></pre><p>编辑为相应源，并更新。</p><pre><code>sudo apt-get update</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pyinstaller打包时可能会造成的一些问题</title>
      <link href="/2020/03/15/Pyinstaller%E6%89%93%E5%8C%85%E6%97%B6%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/15/Pyinstaller%E6%89%93%E5%8C%85%E6%97%B6%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>pyinstaller基本参数</p><pre><code>-D 零散文件，不完全打包-F 只有exe-w 窗口--nonconsole 无控制台</code></pre><p>在打包过程中的问题：</p><p>pyinstaller 在打包过程中，不会将import的库中引用或依赖的文件一并打包，所以我们需要通过-D来打包，并从python文件夹中找到对应的库，复制到打包后的文件夹中</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
