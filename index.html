<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"1b.mk","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="二茂铁Fe的小屋">
<meta property="og:type" content="website">
<meta property="og:title" content="One Bottle of Milk">
<meta property="og:url" content="https://1b.mk/index.html">
<meta property="og:site_name" content="One Bottle of Milk">
<meta property="og:description" content="二茂铁Fe的小屋">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="二茂铁Fe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://1b.mk/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>One Bottle of Milk</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">One Bottle of Milk</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一瓶牛奶</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-工具">

    <a href="/tools/" rel="section"><i class="fas fa-tools fa-fw"></i>工具</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/About/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Ermaotie" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/03/23/Nodejs%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/23/Nodejs%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Nodejs学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-23 23:15:51 / 修改时间：23:59:11" itemprop="dateCreated datePublished" datetime="2021-03-23T23:15:51+08:00">2021-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nodejs学习"><a href="#Nodejs学习" class="headerlink" title="Nodejs学习"></a>Nodejs学习</h1><h2 id="Nodejs简介"><a href="#Nodejs简介" class="headerlink" title="Nodejs简介"></a>Nodejs简介</h2><ul>
<li><strong>在 JavaScript 中，「异步非阻塞」意味着一种以回调函数为基础的编程范式</strong>。</li>
<li>J<strong>avaScript 的异步机制，和引擎 / 运行时有什么关系呢</strong>？</li>
</ul>
<p>可能很多人不会相信，如果我做一门完全支持 ECMA-262 规范的 JavaScript 引擎，这个引擎甚至是完全不需要支持 <code>setTimeout</code> 的。</p>
<p>你没有看错，<code>setTimeout</code> 不在 ECMA-262 里，而是在 W3C 和 WHATWG 规范里。这有什么区别呢？这里也是有历史渊源的。请看 TC39 委员会成立之初的一段历史：</p>
<blockquote>
<p>微软 Internet Explorer 团队负责人 Thomas Reardon 建议委员会不要将 HTML 对象模型的内置库纳入规范中……这些内容应留给 W3C。这一建议被委员会接受，并对委员会的早期成功至关重要……这条 <strong>TC39 只开发独立于平台 / 宿主环境标准</strong>的决定，一直以来都是 TC39 的核心行动准则之一。<br> ——<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136340171">JavaScript 20 年第二部分</a>（还是我翻译的，求个赞）</p>
</blockquote>
<p>什么叫独立于平台和独立于宿主呢？<code>setTimeout</code> 就是典型的例子。纯粹的 JS 引擎不支持 <code>setTimeout</code>，因为它底层依赖操作系统（平台）「把线程挂起」的能力。TC39 制定的 JS 标准可不管这种东西，没想到吧。</p>
<p>那 JS 引擎应该支持什么呢？支持把任务 <strong>Run to Completion</strong> 就行，亦即从头跑到底。所谓任务（Task）指的是去 Eval 一段完整的脚本或执行某个函数。你可以认为浏览器加载 <code>&lt;script&gt;</code> 标签时就是要做一次 Eval，在这中途会注册上这段 JS 里涉及的回调。而 Eval 完成后虽然 JS 不再阻塞，但整个页面运行时则会继续保持活跃。这样每次用户事件到来时，就可以让引擎执行相应的回调函数任务了。<strong>每个任务一旦触发，都是由引擎单线程「一次同步跑到底」的</strong>，这也就是 JavaScript 最基础的执行模型了。</p>
<p>注意到「引擎」和「运行时」概念上的不同了吗？重点来了：<strong>JS 运行时（Runtime）是对 JS 引擎（Engine）的封装，异步能力需要由 JS 运行时开发实现</strong>。浏览器是客户端的 JS 运行时，而 Node.js 就是服务端的 JS 运行时。运行时做了什么？不外乎搭建了一个能调用引擎执行任务的 <strong>Event Loop</strong> 而已。</p>
<blockquote>
<p>你可以认为 JS 引擎就是个无副作用的纯函数，没有运行时提供 IO 能力的话，JS 引擎甚至连 <code>console.log</code> 打日志都是不支持的——ECMAScript 也不包含 <code>console</code> 的标准，这也是 WHATWG 搞的。  </p>
</blockquote>
<p>这样一来，异步问题就重新聚焦到了 Node.js 运行时上面——<strong>Node.js 是如何支持异步的呢</strong>？大家都知道 Node.js = V8 + libuv，而这个 libuv 管的就是平台 IO，封装了<strong>定时器、网络、文件、IPC 通信</strong>等操作系统的 API，基于它就可以用异步非阻塞的方式，跨平台调用操作系统的这些能力，实现自己的 Event Loop 了。</p>
<blockquote>
<p>一个原生应用开发者眼里的操作系统，就是一个提供这些 API 给我调的平台，而不是 PPT 上什么分布式物联网微内核之类乱七八糟的炒作概念。  </p>
</blockquote>
<p>作为科普，这里不必看 V8 + libuv 是怎么搞的，讲一个更简单精炼的实现，看看 Fabrice Bellard 大神是怎么为 QuickJS 引擎配套出 Event Loop 的吧。下面是 <code>quickjs-libc.c</code> 的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main loop which calls the user JS callbacks */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">js_std_loop</span><span class="params">(JSContext *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JSContext *ctx1;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">/* execute the pending jobs */</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &amp;ctx1);</span><br><span class="line">            <span class="keyword">if</span> (err &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    js_std_dump_error(ctx1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!os_poll_func || os_poll_func(ctx))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不就是在双重的死循环里先执行掉所有的 Job 任务，然后调 <code>os_poll_func</code> 吗？那么这里的 for 循环不会吃满 CPU 吗？这就是前面澄清过的地方：<strong>在原生开发中，进程里即便写着个死循环，也未必始终在前台运行，可以通过系统调用将自己挂起</strong>。</p>
<p>因此这里的 <code>os_poll_func</code> 封装的，就是原理类似的 poll 系统调用（准确地说用的其实是 select），从而可以借助操作系统的能力，使得只在「定时器触发、文件描述符读写」等事件发生时，让线程回到前台执行一个 tick，把此时应该运行的 JS 回调 Run to Completion 跑完，而其余时间都在后台挂起。在这条路上继续走下去，就能以经典的异步非阻塞方式来实现整个运行时了。</p>
<p>所以这个双层循环实现的 Event Loop 就很好理解了：外层循环让 OS 挂起自己，内层循环 Run to Completion 式地执行掉所有的 Job，因为 Promise 对应的 Microtask 也需要在单次 Run to Completion 的过程中执行完。至于 Node.js 的 Event Loop，显然会比这个复杂得多，但原理也是类似的。</p>
<blockquote>
<p>用教科书式的简洁代码支撑起工业级的项目，感受到 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28388113">Fabrice Bellard</a> 的实力了吗？  </p>
</blockquote>
<p>如果对 JS 引擎到 JS 运行时的实现原理感兴趣，也欢迎参考我的这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104333176">从 JS 引擎到 JS 运行时（上）</a> - 讲 Event Loop 的基础概念</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104501929">从 JS 引擎到 JS 运行时（下）</a> - 讲基于 libuv 的 Event Loop 实现</li>
</ul>
<p>最后总结一下：</p>
<ul>
<li>什么是 JS 中的异步？<strong>一种基于回调的编程范式</strong>。</li>
<li>JS 的异步和引擎 / 运行时有何关系？<strong>引擎不管异步 IO，要靠运行时搭 Event Loop</strong>。</li>
<li>Node.js 是如何支持异步的？<strong>依赖 libuv，原理上相当于一个双重 for 循环</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval函数是一种接受字符串作为参数，并且可以将接受的字符串转换成js表达式并且立即执行该表达式。 </span><br></pre></td></tr></table></figure>



<h2 id="Nodejs个人使用体会"><a href="#Nodejs个人使用体会" class="headerlink" title="Nodejs个人使用体会"></a>Nodejs个人使用体会</h2><ul>
<li>更偏向于函数式编程，与阻塞式的编程有很大差别。</li>
<li>IO，web请求，等需要耗费时间的需要使用callback来拿到结果并继续处理。</li>
<li>promise也是回调函数，先承诺作，成功失败两种情况分别执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function test(resolve, reject) &#123;</span><br><span class="line">    var timeOut &#x3D; Math.random() * 2;</span><br><span class="line">    log(&#39;set timeout to: &#39; + timeOut + &#39; seconds.&#39;);</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        if (timeOut &lt; 1) &#123;</span><br><span class="line">            log(&#39;call resolve()...&#39;);</span><br><span class="line">            resolve(&#39;200 OK&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            log(&#39;call reject()...&#39;);</span><br><span class="line">            reject(&#39;timeout in &#39; + timeOut + &#39; seconds.&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Promise:</p>
<p>有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Promise(test);</span><br><span class="line">var p2 &#x3D; p1.then(function (result) &#123;</span><br><span class="line">    console.log(&#39;成功：&#39; + result);</span><br><span class="line">&#125;);</span><br><span class="line">var p3 &#x3D; p2.catch(function (reason) &#123;</span><br><span class="line">    console.log(&#39;失败：&#39; + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/02/28/Java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/Java%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Java集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 20:35:30" itemprop="dateCreated datePublished" datetime="2021-02-28T20:35:30+08:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 21:02:27" itemprop="dateModified" datetime="2021-03-03T21:02:27+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>集合(Collection)<ul>
<li>List</li>
<li>Set (无重复元素</li>
<li>Map<br>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</li>
</ul>
</li>
</ul>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<p>Hashtable：一种线程安全的Map实现；（一般不会使用）<br>Vector：一种线程安全的List实现；<br>Stack：基于Vector实现的LIFO的栈。<br>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<p>Enumeration<E>：已被Iterator<E>取代。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; List.of(&quot;apple&quot;,&quot;banana&quot;);</span><br><span class="line">for(Iterator&lt;String&gt; it &#x3D; list.iterator();it.hasNext())&#123;</span><br><span class="line">    String s &#x3D; it.next;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashmap<br>使用hashcode将key直接转换为索引，直接找到所在位置，所在位置为一个List，再在List中找到与key相同的对象返回。<br>因此hashcode()方法不同的key对应尽量不同的hashcode</p>
<ul>
<li>作为key的对象必须覆写equals()方法，且相等的key**equals()**必须相等</li>
<li>作为key的对象必须覆写hashCode()方法</li>
</ul>
<p>如果两个对象相等，则两个对象的hashCode()必须相等；<br>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p>
<p>编写原则：<br>equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。</p>
<p>另外注意，对于放入HashMap的value对象，没有任何要求。</p>
<p>demo:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/28/Spring%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/28/Spring%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-28 11:08:19" itemprop="dateCreated datePublished" datetime="2021-01-28T11:08:19+08:00">2021-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-29 14:12:54" itemprop="dateModified" datetime="2021-01-29T14:12:54+08:00">2021-01-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring开发"><a href="#Spring开发" class="headerlink" title="Spring开发"></a>Spring开发</h1><p>随着Spring越来越受欢迎，在Spring Framework基础上，又诞生了Spring Boot、Spring Cloud、Spring Data、Spring Security等一系列基于Spring Framework的项目。本章我们只介绍Spring Framework，即最核心的Spring框架。后续章节我们还会涉及Spring Boot、Spring Cloud等其他框架。</p>
<p><strong>Spring Framework</strong></p>
<p>Spring Framework主要包括几个模块：</p>
<ul>
<li>支持IoC和AOP的容器；</li>
<li>支持JDBC和ORM的数据访问模块；</li>
<li>支持声明式事务的模块；</li>
<li>支持基于Servlet的MVC开发；</li>
<li>支持基于Reactive的Web开发；</li>
<li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li>
</ul>
<p>我们会依次介绍Spring Framework的主要功能。</p>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p>什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p>
<p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p>
<p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p>
<p>本章我们讨论的IoC容器，主要介绍Spring容器如何对组件进行生命周期管理和配置组装服务。</p>
<h3 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h3><p>Inversion of Control</p>
<p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code>BookService</code>自己并不会创建<code>DataSource</code>，而是等待外部通过<code>setDataSource()</code>方法来注入一个<code>DataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.dataSource &#x3D; dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p>
<ol>
<li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li>
<li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li>
<li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li>
</ol>
<p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p>
<p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;HikariDataSource&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;bookService&quot; class&#x3D;&quot;BookService&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;UserService&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p>
<p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p>
<h4 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h4><p>我们从上面的代码可以看到，依赖注入可以通过<code>set()</code>方法实现。但依赖注入也可以通过构造方法实现。</p>
<p>很多Java类都具有带参数的构造方法，如果我们把<code>BookService</code>改造为通过构造方法注入，那么实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public BookService(DataSource dataSource) &#123;</span><br><span class="line">        this.dataSource &#x3D; dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p>
<h4 id="无侵入容器"><a href="#无侵入容器" class="headerlink" title="无侵入容器"></a>无侵入容器</h4><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p>
<ol>
<li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li>
<li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li>
</ol>
<h3 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h3><ul>
<li>每个<code>&lt;bean ...&gt;</code>都有一个<code>id</code>标识，相当于Bean的唯一ID；</li>
<li>在<code>userService</code>Bean中，通过<code>&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;</code>注入了另一个Bean；</li>
<li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li>
</ul>
<p>Spring容器是通过读取XML文件后使用反射完成的。</p>
<p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;password&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;maximumPoolSize&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;autoCommit&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取Bean:</span><br><span class="line">UserService userService &#x3D; context.getBean(UserService.class);</span><br><span class="line">&#x2F;&#x2F; 正常调用:</span><br><span class="line">User user &#x3D; userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br></pre></td></tr></table></figure>

<p>完整的<code>main()</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">        UserService userService &#x3D; context.getBean(UserService.class);</span><br><span class="line">        User user &#x3D; userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>我们从创建Spring容器的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p>
<p>获得了<code>ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code>ApplicationContext</code>中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserService userService &#x3D; context.getBean(UserService.class);</span><br></pre></td></tr></table></figure>

<p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory factory &#x3D; new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));</span><br><span class="line">MailService mailService &#x3D; factory.getBean(MailService.class);</span><br></pre></td></tr></table></figure>

<p><strong><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于</strong>，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Spring的IoC容器接口是<code>ApplicationContext</code>，并提供了多种实现类；</p>
<p>通过XML配置文件创建IoC容器时，使用<code>ClassPathXmlApplicationContext</code>；</p>
<p>持有IoC容器后，通过<code>getBean()</code>方法获取Bean的引用。</p>
<h3 id="使用Annotation配置"><a href="#使用Annotation配置" class="headerlink" title="使用Annotation配置"></a>使用Annotation配置</h3><p>写好Bean组件，描述出各组件间的配合关系，让容器创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用他们。</p>
<p> 配置方式：</p>
<ul>
<li>xml</li>
<li>Annotation</li>
</ul>
<p>Annotation，Spring可以自动扫描并组装他们。</p>
<p><strong>@Component</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; User</span><br><span class="line">public class User &#123;</span><br><span class="line">    String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是user，即小写开头的类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Userservice &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    public UserService(@Autowired User user) &#123;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一般把<code>@Autowired</code>写在字段上，通常使用package权限的字段，便于测试。</p>
<p>最后，编写一个<code>AppConfig</code>的启动容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        UserService userservice &#x3D; context.getBean(UserService.class);</span><br><span class="line">        &#x2F;&#x2F; 前面的示例未写</span><br><span class="line">        User user &#x3D; UserService.login(&quot;admin&quot;,&quot;passsword&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>main()</code>方法外，<code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure>

<p>使用的实现类是<code>AnnotationConfigApplicationContext</code>，必须传入一个标注了<code>@Configuration</code>的类名。</p>
<p>此外，<code>AppConfig</code>还标注了<code>@ComponentScan</code>，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p>
<p>整个工程结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-annoconfig</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── itranswarp</span><br><span class="line">                    └── learnjava</span><br><span class="line">                        ├── AppConfig.java</span><br><span class="line">                        └── service</span><br><span class="line">                            ├── MailService.java</span><br><span class="line">                            ├── User.java</span><br><span class="line">                            └── UserService.java</span><br></pre></td></tr></table></figure>

<p>使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：</p>
<ul>
<li>每个Bean被标注为<code>@Component</code>并正确使用<code>@Autowired</code>注入；</li>
<li>配置类被标注为<code>@Configuration</code>和<code>@ComponentScan</code>；</li>
<li>所有Bean均在指定包以及子包内。</li>
</ul>
<p>使用<code>@ComponentScan</code>非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>使用Annotation可以大幅简化配置，每个Bean通过<code>@Component</code>和<code>@Autowired</code>注入；</p>
<p>必须合理设计包的层次结构，才能发挥<code>@ComponentScan</code>的威力。</p>
<h3 id="定制Bean"><a href="#定制Bean" class="headerlink" title="定制Bean"></a>定制Bean</h3><p>对于Spring容器来说，当我们把一个Bean标记为<code>@Component</code>后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用<code>getBean(Class)</code>获取到的Bean总是同一个实例。</p>
<p>还有一种Bean，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code>@Scope</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) &#x2F;&#x2F; @Scope(&quot;prototype&quot;)</span><br><span class="line">public class MailSession &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>Spring默认使用Singleton创建Bean，也可指定Scope为Prototype；</p>
<p>可将相同类型的Bean注入<code>List</code>；</p>
<p>可用<code>@Autowired(required=false)</code>允许可选注入；</p>
<p>可用带<code>@Bean</code>标注的方法创建Bean；</p>
<p>可使用<code>@PostConstruct</code>和<code>@PreDestroy</code>对Bean进行初始化和清理；</p>
<p>相同类型的Bean只能有一个指定为<code>@Primary</code>，其他必须用<code>@Quanlifier(&quot;beanName&quot;)</code>指定别名；</p>
<p>注入时，可通过别名<code>@Quanlifier(&quot;beanName&quot;)</code>指定某个Bean；</p>
<p>可以定义<code>FactoryBean</code>来使用工厂模式创建Bean。</p>
<h4 id="注入List"><a href="#注入List" class="headerlink" title="注入List"></a>注入List</h4><p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Validator &#123;</span><br><span class="line">    void validate(String email, String password, String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，分别使用3个<code>Validator</code>对用户参数进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EmailValidator implements Validator &#123;</span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        if (!email.matches(&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid email: &quot; + email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class PasswordValidator implements Validator &#123;</span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        if (!password.matches(&quot;^.&#123;6,20&#125;$&quot;)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid password&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class NameValidator implements Validator &#123;</span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        if (name &#x3D;&#x3D; null || name.isBlank() || name.length() &gt; 20) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid name: &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们通过一个<code>Validators</code>作为入口进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Validators &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    List&lt;Validator&gt; validators;</span><br><span class="line"></span><br><span class="line">    public void validate(String email, String password, String name) &#123;</span><br><span class="line">        for (var validator : this.validators) &#123;</span><br><span class="line">            validator.validate(email, password, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>Validators</code>被注入了一个<code>List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code>Validator</code>的Bean装配为一个<code>List</code>注入进来，这样一来，我们每新增一个<code>Validator</code>类型，就自动被Spring装配到<code>Validators</code>中了，非常方便。</p>
<p>因为Spring是通过扫描classpath获取到所有的Bean，而<code>List</code>是有序的，要指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Order(1)</span><br><span class="line">public class EmailValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Order(2)</span><br><span class="line">public class PasswordValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Order(3)</span><br><span class="line">public class NameValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可选注入"><a href="#可选注入" class="headerlink" title="可选注入"></a>可选注入</h4><p>默认情况下，当我们标记了一个<code>@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常。</p>
<p>可以给<code>@Autowired</code>增加一个<code>required = false</code>的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个参数告诉Spring容器，如果找到一个类型为<code>ZoneId</code>的Bean，就注入，如果找不到，就忽略。</p>
<p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p>
<h4 id="创建第三方Bean"><a href="#创建第三方Bean" class="headerlink" title="创建第三方Bean"></a>创建第三方Bean</h4><p>如果一个Bean不在我们自己的package管理之内，例如<code>ZoneId</code>，如何创建它？</p>
<p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个Bean:</span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring对标记为<code>@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p>
<h4 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h4><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个<code>init()</code>方法进行初始化，定义一个<code>shutdown()</code>方法进行清理，然后，引入JSR-250定义的Annotation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.annotation&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.annotation-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;Init mail service with zoneId &#x3D; &quot; + this.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        System.out.println(&quot;Shutdown mail service&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring容器会对上述Bean做如下初始化流程：</p>
<ul>
<li>调用构造方法创建<code>MailService</code>实例；</li>
<li>根据<code>@Autowired</code>进行注入；</li>
<li>调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li>
</ul>
<p>而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</p>
<p>Spring只根据Annotation查找<em>无参数</em>方法，对方法名不作要求。</p>
<h4 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h4><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code>DataSource</code>实例。</p>
<p>如果我们在<code>@Configuration</code>类中创建了多个同类型的Bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneOfUTC8() &#123;</span><br><span class="line">        return ZoneId.of(&quot;UTC+08:00&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring会报<code>NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。</p>
<p>这个时候，需要给每个Bean添加不同的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean(&quot;z&quot;)</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;utc8&quot;)</span><br><span class="line">    ZoneId createZoneOfUTC8() &#123;</span><br><span class="line">        return ZoneId.of(&quot;UTC+08:00&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用<code>@Bean(&quot;name&quot;)</code>指定别名，也可以用<code>@Bean</code>+<code>@Qualifier(&quot;name&quot;)</code>指定别名。</p>
<p>存在多个同类型的Bean时，注入<code>ZoneId</code>又会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException: No qualifying bean of type &#39;java.time.ZoneId&#39; available: expected single matching bean but found 2</span><br></pre></td></tr></table></figure>

<p>意思是期待找到唯一的<code>ZoneId</code>类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    @Qualifier(&quot;z&quot;) &#x2F;&#x2F; 指定注入名称为&quot;z&quot;的ZoneId</span><br><span class="line">    ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方法是把其中某个Bean指定为<code>@Primary</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary &#x2F;&#x2F; 指定为主要Bean</span><br><span class="line">    @Qualifier(&quot;z&quot;)</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        return ZoneId.of(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;utc8&quot;)</span><br><span class="line">    ZoneId createZoneOfUTC8() &#123;</span><br><span class="line">        return ZoneId.of(&quot;UTC+08:00&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code>@Primary</code>的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为<code>@Primary</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    DataSource createMasterDataSource() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;slave&quot;)</span><br><span class="line">    DataSource createSlaveDataSource() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p>
<h4 id="使用FactoryBean"><a href="#使用FactoryBean" class="headerlink" title="使用FactoryBean"></a>使用FactoryBean</h4><p>我们在设计模式的<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319170474017">工厂方法</a>中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p>
<p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ZoneIdFactoryBean implements FactoryBean&lt;ZoneId&gt; &#123;</span><br><span class="line"></span><br><span class="line">    String zone &#x3D; &quot;Z&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ZoneId getObject() throws Exception &#123;</span><br><span class="line">        return ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p>
<p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p>
<h3 id="使用Resource"><a href="#使用Resource" class="headerlink" title="使用Resource"></a>使用Resource</h3><p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p>
<p>例如，AppService需要读取<code>logo.txt</code>这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p>
<p>Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AppService &#123;</span><br><span class="line">    @Value(&quot;classpath:&#x2F;logo.txt&quot;)</span><br><span class="line">    private Resource resource;</span><br><span class="line"></span><br><span class="line">    private String logo;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() throws IOException &#123;</span><br><span class="line">        try (var reader &#x3D; new BufferedReader(</span><br><span class="line">                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            this.logo &#x3D; reader.lines().collect(Collectors.joining(&quot;\n&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入<code>Resource</code>最常用的方式是通过classpath，即类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p>
<p>也可以直接指定文件的路径，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;file:&#x2F;path&#x2F;to&#x2F;logo.txt&quot;)</span><br><span class="line">private Resource resource;</span><br></pre></td></tr></table></figure>

<p>但使用classpath是最简单的方式。上述工程结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-resource</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               └── AppService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── logo.txt</span><br></pre></td></tr></table></figure>

<p>使用Maven的标准目录结构，所有资源文件放入<code>src/main/resources</code>即可。</p>
<p>示例： <code>app.properties</code></p>
<h3 id="注入配置"><a href="#注入配置" class="headerlink" title="注入配置"></a>注入配置</h3><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p>
<p>例如，<code>MailService</code>根据配置的<code>app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的<code>Resource</code>来读取位于classpath下的一个<code>app.properties</code>文件。但是，这样仍然比较繁琐。</p>
<p>Spring容器还提供了一个更简单的<code>@PropertySource</code>来自动读取配置文件。我们只需要在<code>@Configuration</code>配置类上再添加一个注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@PropertySource(&quot;app.properties&quot;) &#x2F;&#x2F; 表示读取classpath的app.properties</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        return ZoneId.of(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring容器看到<code>@PropertySource(&quot;app.properties&quot;)</code>注解后，自动读取这个配置文件，然后，我们使用<code>@Value</code>正常注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span><br><span class="line">String zoneId;</span><br></pre></td></tr></table></figure>

<p>注意注入的字符串语法，它的格式如下：</p>
<ul>
<li><code>&quot;$&#123;app.zone&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，如果key不存在，启动将报错；</li>
<li><code>&quot;$&#123;app.zone:Z&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，但如果key不存在，就使用默认值<code>Z</code>。</li>
</ul>
<p>这样一来，我们就可以根据<code>app.zone</code>的配置来创建<code>ZoneId</code>。</p>
<p>还可以把注入的注解写到方法参数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">ZoneId createZoneId(@Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId) &#123;</span><br><span class="line">    return ZoneId.of(zoneId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p>
<p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code>SmtpConfig</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SmtpConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;smtp.host&#125;&quot;)</span><br><span class="line">    private String host;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;smtp.port:25&#125;&quot;)</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    public String getHost() &#123;</span><br><span class="line">        return host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPort() &#123;</span><br><span class="line">        return port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span><br><span class="line">    private String smtpHost;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span><br><span class="line">    private int smtpPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意观察<code>#&#123;&#125;</code>这种注入语法，它和<code>$&#123;key&#125;</code>不同的是，<code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性，即调用<code>getHost()</code>方法。一个Class名为<code>SmtpConfig</code>的Bean，它在Spring容器中的默认名称就是<code>smtpConfig</code>，除非用<code>@Qualifier</code>指定了名称。</p>
<p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code>#&#123;bean.property&#125;</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果<code>SmtpConfig</code>决定从数据库中读取相关配置项，那么<code>MailService</code>注入的<code>@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</code>仍然可以不修改正常运行。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>Spring容器可以通过<code>@PropertySource</code>自动读取配置，并以<code>@Value(&quot;$&#123;key&#125;&quot;)</code>的形式注入；</p>
<p>可以通过<code>$&#123;key:defaultValue&#125;</code>指定默认值；</p>
<p>以<code>#&#123;bean.property&#125;</code>形式注入时，Spring容器自动把指定Bean的指定属性值注入。</p>
<h3 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h3><p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p>
<p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p>
<ul>
<li>native</li>
<li>test</li>
<li>production</li>
</ul>
<p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建。例如，以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;!test&quot;)</span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        return ZoneId.systemDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;test&quot;)</span><br><span class="line">    ZoneId creat eZoneIdForTest() &#123;</span><br><span class="line">        return ZoneId.of(&quot;America&#x2F;New_York&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前的Profile设置为<code>test</code>，则Spring容器会调用<code>createZoneIdForTest()</code>创建<code>ZoneId</code>，否则，调用<code>createZoneId()</code>创建<code>ZoneId</code>。注意到<code>@Profile(&quot;!test&quot;)</code>表示非test环境。</p>
<p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p>
<p>实际上，Spring允许指定多个Profile，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active&#x3D;test,master</span><br></pre></td></tr></table></figure>

<p>可以表示<code>test</code>环境，并使用<code>master</code>分支代码。</p>
<p>要满足多个Profile条件，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;) &#x2F;&#x2F; 同时满足test和master</span><br><span class="line">ZoneId createZoneId() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Conditional"><a href="#使用Conditional" class="headerlink" title="使用Conditional"></a>使用Conditional</h4><p>除了根据<code>@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code>@Conditional</code>决定是否创建某个Bean。</p>
<p>例如，我们对<code>SmtpMailService</code>添加如下注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Conditional(OnSmtpEnvCondition.class)</span><br><span class="line">public class SmtpMailService implements MailService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的意思是，如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。<code>OnSmtpEnvCondition</code>的条件是什么呢？我们看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class OnSmtpEnvCondition implements Condition &#123;</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        return &quot;true&quot;.equalsIgnoreCase(System.getenv(&quot;smtp&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>Spring允许通过<code>@Profile</code>配置不同的Bean；</p>
<p>Spring还提供了<code>@Conditional</code>来进行条件装配，Spring Boot在此基础上进一步提供了基于配置、Class、Bean等条件进行装配。</p>
<h2 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h2><p>AOP是Aspect Oriented Programming，即面向切面编程。</p>
<p>那什么是AOP？</p>
<p>我们先回顾一下OOP：Object Oriented Programming，OOP作为面向对象编程的模式，获得了巨大的成功，OOP的主要功能是数据封装、继承和多态。</p>
<p>而AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。</p>
<p>要理解AOP的概念，我们先用OOP举例，比如一个业务组件<code>BookService</code>，它有几个业务方法：</p>
<ul>
<li>createBook：添加新的Book；</li>
<li>updateBook：修改Book；</li>
<li>deleteBook：删除Book。</li>
</ul>
<p>对每个业务方法，例如，<code>createBook()</code>，除了业务逻辑，还需要安全检查、日志记录和事务处理，它的代码像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    public void createBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        Transaction tx &#x3D; startTransaction();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 核心业务逻辑</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(&quot;created book: &quot; + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续编写<code>updateBook()</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    public void updateBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        Transaction tx &#x3D; startTransaction();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 核心业务逻辑</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(&quot;updated book: &quot; + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化。</p>
<p>考察业务模型可以发现，<code>BookService</code>关心的是自身的核心逻辑，但整个系统还要求关注安全检查、日志、事务等功能，这些功能实际上“横跨”多个业务方法，为了实现这些功能，不得不在每个业务方法上重复编写代码。</p>
<p>一种可行的方式是使用<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">Proxy模式</a>，将某个功能，例如，权限检查，放入Proxy中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SecurityCheckBookService implements BookService &#123;</span><br><span class="line">    private final BookService target;</span><br><span class="line"></span><br><span class="line">    public SecurityCheckBookService(BookService target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteBook(Book book) &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void securityCheck() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的缺点是比较麻烦，必须先抽取接口，然后，针对每个方法实现Proxy。</p>
<p>另一种方法是，既然<code>SecurityCheckBookService</code>的代码都是标准的Proxy样板代码，不如把权限检查视作一种切面（Aspect），把日志、事务也视为切面，然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p>
<p>如果我们以AOP的视角来编写上述业务，可以依次实现：</p>
<ol>
<li>核心逻辑，即BookService；</li>
<li>切面逻辑，即：</li>
<li>权限检查的Aspect；</li>
<li>日志的Aspect；</li>
<li>事务的Aspect。</li>
</ol>
<p>然后，以某种方式，让框架来把上述3个Aspect以Proxy的方式“织入”到<code>BookService</code>中，这样一来，就不必编写复杂而冗长的Proxy模式。</p>
<h4 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h4><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p>
<p>在Java平台上，对于AOP的织入，有3种方式：</p>
<ol>
<li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li>
<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li>
</ol>
<p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>或者<a target="_blank" rel="noopener" href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p>
<p>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p>
<p>需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。</p>
<h3 id="装配AOP"><a href="#装配AOP" class="headerlink" title="装配AOP"></a>装配AOP</h3><p>在AOP编程中，我们经常会遇到下面的概念：</p>
<ul>
<li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li>
<li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li>
<li>Pointcut：切入点，即一组连接点的集合；</li>
<li>Advice：增强，指特定连接点上执行的动作；</li>
<li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li>
<li>Weaving：织入，指将切面整合到程序的执行流程中；</li>
<li>Interceptor：拦截器，是一种实现增强的方式；</li>
<li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li>
<li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li>
</ul>
<p>看完上述术语，是不是感觉对AOP有了进一步的困惑？其实，我们不用关心AOP创造的“术语”，只需要理解AOP本质上只是一种代理模式的实现方式，在Spring的容器中实现AOP特别方便。</p>
<p>我们以<code>UserService</code>和<code>MailService</code>为例，这两个属于核心业务逻辑，现在，我们准备给<code>UserService</code>的每个业务方法执行前添加日志，给<code>MailService</code>的每个业务方法执行前后添加日志，在Spring中，需要以下步骤：</p>
<p>首先，我们通过Maven引入Spring对AOP的支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便，因为它的定义比较简单。</p>
<p>然后，我们定义一个<code>LoggingAspect</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line">    &#x2F;&#x2F; 在执行UserService的每个方法前执行:</span><br><span class="line">    @Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span><br><span class="line">    public void doAccessCheck() &#123;</span><br><span class="line">        System.err.println(&quot;[Before] do access check...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在执行MailService的每个方法前后执行:</span><br><span class="line">    @Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span><br><span class="line">    public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        System.err.println(&quot;[Around] start &quot; + pjp.getSignature());</span><br><span class="line">        Object retVal &#x3D; pjp.proceed();</span><br><span class="line">        System.err.println(&quot;[Around] done &quot; + pjp.getSignature());</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察<code>doAccessCheck()</code>方法，我们定义了一个<code>@Before</code>注解，后面的字符串是告诉AspectJ应该在何处执行该方法，这里写的意思是：执行<code>UserService</code>的每个<code>public</code>方法前执行<code>doAccessCheck()</code>代码。</p>
<p>再观察<code>doLogging()</code>方法，我们定义了一个<code>@Around</code>注解，它和<code>@Before</code>不同，<code>@Around</code>可以决定是否执行目标方法，因此，我们在<code>doLogging()</code>内部先打印日志，再调用方法，最后打印日志后返回结果。</p>
<p>在<code>LoggingAspect</code>类的声明处，除了用<code>@Component</code>表示它本身也是一个Bean外，我们再加上<code>@Aspect</code>注解，表示它的<code>@Before</code>标注的方法需要注入到<code>UserService</code>的每个<code>public</code>方法执行前，<code>@Around</code>标注的方法需要注入到<code>MailService</code>的每个<code>public</code>方法执行前后。</p>
<p>紧接着，我们需要给<code>@Configuration</code>类加上一个<code>@EnableAspectJAutoProxy</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。执行代码，我们可以看到以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">Welcome, test!</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br><span class="line">Hi, Bob! You are logged in at 2020-02-14T23:13:52.167996+08:00[Asia&#x2F;Shanghai]</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br></pre></td></tr></table></figure>

<p>这说明执行业务逻辑前后，确实执行了我们定义的Aspect（即<code>LoggingAspect</code>的方法）。</p>
<p>有些童鞋会问，<code>LoggingAspect</code>定义的方法，是如何注入到其他Bean的呢？</p>
<p>其实AOP的原理非常简单。我们以<code>LoggingAspect.doAccessCheck()</code>为例，要把它注入到<code>UserService</code>的每个<code>public</code>方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public UserServiceAopProxy extends UserService &#123;</span><br><span class="line">    private UserService target;</span><br><span class="line">    private LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    public UserServiceAopProxy(UserService target, LoggingAspect aspect) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        this.aspect &#x3D; aspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User login(String email, String password) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先执行Aspect的代码:</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        &#x2F;&#x2F; 再执行UserService的逻辑:</span><br><span class="line">        return target.login(email, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User register(String email, String password, String name) &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        return target.register(email, password, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的<code>UserService</code>（原始的<code>UserService</code>实例作为内部变量隐藏在<code>UserServiceAopProxy</code>中）。如果我们打印从Spring容器获取的<code>UserService</code>实例类型，它类似<code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p>
<p> Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p>
<p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p>
<ol>
<li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li>
<li>标记<code>@Component</code>和<code>@Aspect</code>；</li>
<li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li>
</ol>
<p>至于AspectJ的注入语法则比较复杂，请参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">Spring文档</a>。</p>
<p>Spring也提供其他方法来装配AOP，但都没有使用AspectJ注解的方式来得简洁明了，所以我们不再作介绍。</p>
<h4 id="拦截器类型"><a href="#拦截器类型" class="headerlink" title="拦截器类型"></a>拦截器类型</h4><p>顾名思义，拦截器有以下类型：</p>
<ul>
<li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li>
<li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li>
<li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li>
<li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li>
<li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li>
</ul>
<h3 id="注解装配AOP"><a href="#注解装配AOP" class="headerlink" title="注解装配AOP"></a>注解装配AOP</h3><p>上一节我们讲解了使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code>语法来定义应该如何装配AOP。</p>
<p>在实际项目中，这种写法其实很少使用。假设你写了一个<code>SecurityAspect</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class SecurityAspect &#123;</span><br><span class="line">    @Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        if (SecurityContext.getCurrentUser() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;check failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个<code>check()</code>方法拦截。</p>
<p>还有的童鞋喜欢用方法名前缀进行拦截：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;execution(public * update*(..))&quot;)</span><br><span class="line">public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F; 对update开头的方法切换数据源:</span><br><span class="line">    String old &#x3D; setCurrentDataSource(&quot;master&quot;);</span><br><span class="line">    Object retVal &#x3D; pjp.proceed();</span><br><span class="line">    restoreCurrentDataSource(old);</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p>
<p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p>
<p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的<code>@Transactional</code>就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上<code>@Transactional</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    &#x2F;&#x2F; 有事务:</span><br><span class="line">    @Transactional</span><br><span class="line">    public User createUser(String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 无事务:</span><br><span class="line">    public boolean isValidName(String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 有事务:</span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateUser(User user) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接在class级别注解，表示“所有public方法都被安排了”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Transactional</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>@Transactional</code>，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p>
<p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(METHOD)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface MetricTime &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要被监控的关键方法上标注该注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    &#x2F;&#x2F; 监控register()方法性能:</span><br><span class="line">    @MetricTime(&quot;register&quot;)</span><br><span class="line">    public User register(String email, String password, String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们定义<code>MetricAspect</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MetricAspect &#123;</span><br><span class="line">    @Around(&quot;@annotation(metricTime)&quot;)</span><br><span class="line">    public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable &#123;</span><br><span class="line">        String name &#x3D; metricTime.value();</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            return joinPoint.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            long t &#x3D; System.currentTimeMillis() - start;</span><br><span class="line">            &#x2F;&#x2F; 写入日志或发送至JMX:</span><br><span class="line">            System.err.println(&quot;[Metrics] &quot; + name + &quot;: &quot; + t + &quot;ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法参数类型是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p>
<p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome, Bob!</span><br><span class="line">[Metrics] register: 16ms</span><br></pre></td></tr></table></figure>

<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>使用注解实现AOP需要先定义注解，然后使用<code>@Around(&quot;@annotation(name)&quot;)</code>实现装配；</p>
<p>使用注解既简单，又能明确标识AOP装配，是使用AOP推荐的方式。</p>
<h3 id="AOP避坑指南"><a href="#AOP避坑指南" class="headerlink" title="AOP避坑指南"></a>AOP避坑指南</h3><p>无论是使用AspectJ语法，还是配合Annotation，使用AOP，实际上就是让Spring自动为我们创建一个Proxy，使得调用方能无感知地调用指定方法，但运行期却动态“织入”了其他逻辑，因此，AOP本质上就是一个<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">代理模式</a>。</p>
<p>因为Spring使用了CGLIB来实现运行期动态创建Proxy，如果我们没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。</p>
<p>我们来看一个实际的例子。</p>
<p>假设我们定义了一个<code>UserService</code>的Bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    &#x2F;&#x2F; 成员变量:</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造方法:</span><br><span class="line">    public UserService() &#123;</span><br><span class="line">        System.out.println(&quot;UserService(): init...&quot;);</span><br><span class="line">        System.out.println(&quot;UserService(): zoneId &#x3D; &quot; + this.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; public方法:</span><br><span class="line">    public ZoneId getZoneId() &#123;</span><br><span class="line">        return zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; public final方法:</span><br><span class="line">    public final ZoneId getFinalZoneId() &#123;</span><br><span class="line">        return zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写个<code>MailService</code>，并注入<code>UserService</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        ZoneId zoneId &#x3D; userService.zoneId;</span><br><span class="line">        String dt &#x3D; ZonedDateTime.now(zoneId).toString();</span><br><span class="line">        return &quot;Hello, it is &quot; + dt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后用<code>main()</code>方法测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        MailService mailService &#x3D; context.getBean(MailService.class);</span><br><span class="line">        System.out.println(mailService.sendMail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看输出，一切正常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService(): init...</span><br><span class="line">UserService(): zoneId &#x3D; Asia&#x2F;Shanghai</span><br><span class="line">Hello, it is 2020-04-12T10:23:22.917721+08:00[Asia&#x2F;Shanghai]</span><br></pre></td></tr></table></figure>

<p>下一步，我们给<code>UserService</code>加上AOP支持，就添加一个最简单的<code>LoggingAspect</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line">    @Before(&quot;execution(public * com..*.UserService.*(..))&quot;)</span><br><span class="line">    public void doAccessCheck() &#123;</span><br><span class="line">        System.err.println(&quot;[Before] do access check...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别忘了在<code>AppConfig</code>上加上<code>@EnableAspectJAutoProxy</code>。再次运行，不出意外的话，会得到一个<code>NullPointerException</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: zone</span><br><span class="line">    at java.base&#x2F;java.util.Objects.requireNonNull(Objects.java:246)</span><br><span class="line">    at java.base&#x2F;java.time.Clock.system(Clock.java:203)</span><br><span class="line">    at java.base&#x2F;java.time.ZonedDateTime.now(ZonedDateTime.java:216)</span><br><span class="line">    at com.itranswarp.learnjava.service.MailService.sendMail(MailService.java:19)</span><br><span class="line">    at com.itranswarp.learnjava.AppConfig.main(AppConfig.java:21)</span><br></pre></td></tr></table></figure>

<p>仔细跟踪代码，会发现<code>null</code>值出现在<code>MailService.sendMail()</code>内部的这一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        ZoneId zoneId &#x3D; userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); &#x2F;&#x2F; null</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还故意在<code>UserService</code>中特意用<code>final</code>修饰了一下成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>final</code>标注的成员变量为<code>null</code>？逗我呢？</p>
<h4 id="怎么肥四？"><a href="#怎么肥四？" class="headerlink" title="怎么肥四？"></a>怎么肥四？</h4><p>为什么加了AOP就报NPE，去了AOP就一切正常？<code>final</code>字段不执行，难道JVM有问题？为了解答这个诡异的问题，我们需要深入理解Spring使用CGLIB生成Proxy的原理：</p>
<p>第一步，正常创建一个<code>UserService</code>的原始实例，这是通过反射调用构造方法实现的，它的行为和我们预期的完全一致；</p>
<p>第二步，通过CGLIB创建一个<code>UserService</code>的子类，并引用了原始实例和<code>LoggingAspect</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public UserService$$EnhancerBySpringCGLIB extends UserService &#123;</span><br><span class="line">    UserService target;</span><br><span class="line">    LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    public UserService$$EnhancerBySpringCGLIB() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZoneId getZoneId() &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        return target.getZoneId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们观察Spring创建的AOP代理，它的类名总是类似<code>UserService$$EnhancerBySpringCGLIB$$1c76af9d</code>（你没看错，Java的类名实际上允许<code>$</code>字符）。为了让调用方获得<code>UserService</code>的引用，它必须继承自<code>UserService</code>。然后，该代理类会覆写所有<code>public</code>和<code>protected</code>方法，并在内部将调用委托给原始的<code>UserService</code>实例。</p>
<p>这里出现了两个<code>UserService</code>实例：</p>
<p>一个是我们代码中定义的<em>原始实例</em>，它的成员变量已经按照我们预期的方式被初始化完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserService original &#x3D; new UserService();</span><br></pre></td></tr></table></figure>

<p>第二个<code>UserService</code>实例实际上类型是<code>UserService$$EnhancerBySpringCGLIB</code>，它引用了原始的<code>UserService</code>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService$$EnhancerBySpringCGLIB proxy &#x3D; new UserService$$EnhancerBySpringCGLIB();</span><br><span class="line">proxy.target &#x3D; original;</span><br><span class="line">proxy.aspect &#x3D; ...</span><br></pre></td></tr></table></figure>

<p>注意到这种情况仅出现在启用了AOP的情况，此刻，从<code>ApplicationContext</code>中获取的<code>UserService</code>实例是proxy，注入到<code>MailService</code>中的<code>UserService</code>实例也是proxy。</p>
<p>那么最终的问题来了：proxy实例的成员变量，也就是从<code>UserService</code>继承的<code>zoneId</code>，它的值是<code>null</code>。</p>
<p>原因在于，<code>UserService</code>成员变量的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>UserService$$EnhancerBySpringCGLIB</code>中，并未执行。原因是，没必要初始化proxy的成员变量，因为proxy的目的是代理方法。</p>
<p>实际上，成员变量的初始化是在构造方法中完成的。这是我们看到的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">    public UserService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是编译器实际编译的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    public final ZoneId zoneId;</span><br><span class="line">    public UserService() &#123;</span><br><span class="line">        super(); &#x2F;&#x2F; 构造方法的第一行代码总是调用super()</span><br><span class="line">        zoneId &#x3D; ZoneId.systemDefault(); &#x2F;&#x2F; 继续初始化成员变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，对于Spring通过CGLIB动态创建的<code>UserService$$EnhancerBySpringCGLIB</code>代理类，它的构造方法中，并未调用<code>super()</code>，因此，从父类继承的成员变量，包括<code>final</code>类型的成员变量，统统都没有初始化。</p>
<p>有的童鞋会问：Java语言规定，任何类的构造方法，第一行必须调用<code>super()</code>，如果没有，编译器会自动加上，怎么Spring的CGLIB就可以搞特殊？</p>
<p>这是因为自动加<code>super()</code>的功能是Java编译器实现的，它发现你没加，就自动给加上，发现你加错了，就报编译错误。但实际上，如果直接构造字节码，一个类的构造方法中，不一定非要调用<code>super()</code>。Spring使用CGLIB构造的Proxy类，是直接生成字节码，并没有源码-编译-字节码这个步骤，因此：</p>
<p> Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！</p>
<p>再考察<code>MailService</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        ZoneId zoneId &#x3D; userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); &#x2F;&#x2F; null</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有启用AOP，注入的是原始的<code>UserService</code>实例，那么一切正常，因为<code>UserService</code>实例的<code>zoneId</code>字段已经被正确初始化了。</p>
<p>如果启动了AOP，注入的是代理后的<code>UserService$$EnhancerBySpringCGLIB</code>实例，那么问题大了：获取的<code>UserService$$EnhancerBySpringCGLIB</code>实例的<code>zoneId</code>字段，永远为<code>null</code>。</p>
<p>那么问题来了：启用了AOP，如何修复？</p>
<p>修复很简单，只需要把直接访问字段的代码，改为通过方法访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public String sendMail() &#123;</span><br><span class="line">        &#x2F;&#x2F; 不要直接访问UserService的字段:</span><br><span class="line">        ZoneId zoneId &#x3D; userService.getZoneId();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论注入的<code>UserService</code>是原始实例还是代理实例，<code>getZoneId()</code>都能正常工作，因为代理类会覆写<code>getZoneId()</code>方法，并将其委托给原始实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public UserService$$EnhancerBySpringCGLIB extends UserService &#123;</span><br><span class="line">    UserService target &#x3D; ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public ZoneId getZoneId() &#123;</span><br><span class="line">        return target.getZoneId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到我们还给<code>UserService</code>添加了一个<code>public</code>+<code>final</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    ...</span><br><span class="line">    public final ZoneId getFinalZoneId() &#123;</span><br><span class="line">        return zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>MailService</code>中，调用的不是<code>getZoneId()</code>，而是<code>getFinalZoneId()</code>，又会出现<code>NullPointerException</code>，这是因为，代理类无法覆写<code>final</code>方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的<code>zoneId</code>字段，即<code>null</code>。</p>
<p>实际上，如果我们加上日志，Spring在启动时会打印一个警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10:43:09.929 [main] DEBUG org.springframework.aop.framework.CglibAopProxy - Final method [public final java.time.ZoneId xxx.UserService.getFinalZoneId()] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance.</span><br></pre></td></tr></table></figure>

<p>上面的日志大意就是，因为被代理的<code>UserService</code>有一个<code>final</code>方法<code>getFinalZoneId()</code>，这会导致其他Bean如果调用此方法，无法将其代理到真正的原始实例，从而可能发生NPE异常。</p>
<p>因此，正确使用AOP，我们需要一个避坑指南：</p>
<ol>
<li>访问被注入的Bean时，总是调用方法而非直接访问字段；</li>
<li>编写Bean时，如果可能会被代理，就不要编写<code>public final</code>方法。</li>
</ol>
<p>这样才能保证有没有AOP，代码都能正常工作。</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>为什么Spring刻意不初始化Proxy继承的字段？</p>
<p>如果一个Bean不允许任何AOP代理，应该怎么做来“保护”自己在运行期不会被代理？</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>从<a target="_blank" rel="noopener" href="https://gitee.com/"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=" alt="img"></a>下载练习：<a target="_blank" rel="noopener" href="https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/210.Spring%E5%BC%80%E5%8F%91.1266263217140032/20.%E4%BD%BF%E7%94%A8AOP.1266265125480448/30.AOP%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97.1339039378571298/spring-aop-field.zip?utm_source=blog_lxf">修复启用AOP导致的NPE</a> （推荐使用<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664">IDE练习插件</a>快速下载）</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>由于Spring通过CGLIB实现代理类，我们要避免直接访问Bean的字段，以及由<code>final</code>方法带来的“未代理”问题。</p>
<p>遇到CglibAopProxy的相关日志，务必要仔细检查，防止因为AOP出现NPE异常。</p>
<h2 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h2><p>数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。</p>
<p>我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特定厂商的驱动。</p>
<p>使用JDBC虽然简单，但代码比较繁琐。Spring为了简化数据库访问，主要做了以下几点工作：</p>
<ul>
<li>提供了简化的访问JDBC的模板类，不必手动释放资源；</li>
<li>提供了一个统一的DAO类以实现Data Access Object模式；</li>
<li>把<code>SQLException</code>封装为<code>DataAccessException</code>，这个异常是一个<code>RuntimeException</code>，并且让我们能区分SQL异常的原因，例如，<code>DuplicateKeyException</code>表示违反了一个唯一约束；</li>
<li>能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。</li>
</ul>
<p>本章我们将详细讲解在Spring中访问数据库的最佳实践。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-21 22:38:13" itemprop="dateCreated datePublished" datetime="2021-01-21T22:38:13+08:00">2021-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 12:09:45" itemprop="dateModified" datetime="2021-01-22T12:09:45+08:00">2021-01-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>title: White-Jotter</p>
<p>date: 2021-1-21 </p>
<p>tags:</p>
<p>-–</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>即 Design Pattern。为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p>
<p>设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类，我们后续会一一讲解。</p>
<p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。</p>
<h2 id="创新型模式"><a href="#创新型模式" class="headerlink" title="创新型模式"></a>创新型模式</h2><p>核心思想为将对象创建与使用分离。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><em>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</em></p>
<p>工厂方法即Factory Method，是一种对象创建型模式。</p>
<p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│   Product   │      │   Factory   │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br><span class="line">       ▲                    ▲</span><br><span class="line">       │                    │</span><br><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure>

<p>解耦思想：</p>
<p>用的管用，做的管做，互不影响</p>
<p>实现：</p>
<p>例子：</p>
<p>练习</p>
<p>使用静态工厂方法实现一个类似<code>20200202</code>的整数转换为<code>LocalDate</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class LocalDateFactory &#123;</span><br><span class="line">    public static LocalDate fromInt(int yyyyMMdd) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<p>首先是抽象类接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package 设计模式.工厂方法;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public interface LDFactory &#123;</span><br><span class="line">    LocalDate fromInt(int yyyyMMdd);</span><br><span class="line">    &#x2F;&#x2F; 静态方法调用</span><br><span class="line">    static LDFactoryImpl getFactory() &#123;</span><br><span class="line">        return new LDFactoryImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继承抽象类接口的实体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package 设计模式.工厂方法;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class LDFactoryImpl implements LDFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public LocalDate fromInt(int yyyyMMdd) &#123;</span><br><span class="line">    &#x2F;&#x2F; 具体业务实现</span><br><span class="line">        int yyyy &#x3D; yyyyMMdd &#x2F; 10000;</span><br><span class="line">        int mmdd &#x3D; yyyyMMdd % 10000;</span><br><span class="line">        int mm &#x3D; mmdd &#x2F; 100;</span><br><span class="line">        int dd &#x3D; mmdd % 100;</span><br><span class="line">        System.out.println(LocalDate.of(yyyy,mm,dd));</span><br><span class="line">        return LocalDate.of(yyyy,mm,dd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package 设计模式.工厂方法;</span><br><span class="line"></span><br><span class="line">public class client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 类似黑盒测试，实现交给黑盒子，调用时直接调取抽象类</span><br><span class="line">        &#x2F;&#x2F; 使用时不需要更换方法</span><br><span class="line">        LDFactory factory &#x3D; LDFactory.getFactory();</span><br><span class="line">        factory.fromInt(20010626);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上称为<code>静态工厂方法</code></p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><em>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</em>（Abstract Factory）</p>
<p>本质就是不同静态工厂的选择，</p>
<ul>
<li>用户定义接口</li>
<li>第三方实现接口并实现其中功能</li>
<li>用户实现第三方的接口，并按定义的方法使用</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><em>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</em></p>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<p>我们仍然以Markdown转HTML为例，因为直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># this is a heading</span><br></pre></td></tr></table></figure>

<p>转换成HTML就很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;this is a heading&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>因此，我们把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p>
<ul>
<li>如果以<code>#</code>开头，使用<code>HeadingBuilder</code>转换；</li>
<li>如果以<code>&gt;</code>开头，使用<code>QuoteBuilder</code>转换；</li>
<li>如果以<code>---</code>开头，使用<code>HrBuilder</code>转换；</li>
<li>其余使用<code>ParagraphBuilder</code>转换。</li>
</ul>
<p>这个<code>HtmlBuilder</code>写出来如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HtmlBuilder &#123;</span><br><span class="line">    private HeadingBuilder headingBuilder &#x3D; new HeadingBuilder();</span><br><span class="line">    private HrBuilder hrBuilder &#x3D; new HrBuilder();</span><br><span class="line">    private ParagraphBuilder paragraphBuilder &#x3D; new ParagraphBuilder();</span><br><span class="line">    private QuoteBuilder quoteBuilder &#x3D; new QuoteBuilder();</span><br><span class="line"></span><br><span class="line">    public String toHtml(String markdown) &#123;</span><br><span class="line">        StringBuilder buffer &#x3D; new StringBuilder();</span><br><span class="line">        markdown.lines().forEach(line -&gt; &#123;</span><br><span class="line">            if (line.startsWith(&quot;#&quot;)) &#123;</span><br><span class="line">                buffer.append(headingBuilder.buildHeading(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125; else if (line.startsWith(&quot;&gt;&quot;)) &#123;</span><br><span class="line">                buffer.append(quoteBuilder.buildQuote(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125; else if (line.startsWith(&quot;---&quot;)) &#123;</span><br><span class="line">                buffer.append(hrBuilder.buildHr(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                buffer.append(paragraphBuilder.buildParagraph(line)).append(&#39;\n&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意观察上述代码，<code>HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code>XxxBuilder</code>去转换，最后，把所有转换的结果组合起来，返回给客户端。</p>
<p>这样一来，我们只需要针对每一种类型编写不同的Builder。例如，针对以<code>#</code>开头的行，需要<code>HeadingBuilder</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HeadingBuilder &#123;</span><br><span class="line">    public String buildHeading(String line) &#123;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        while (line.charAt(0) &#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            line &#x3D; line.substring(1);</span><br><span class="line">        &#125;</span><br><span class="line">        return String.format(&quot;&lt;h%d&gt;%s&lt;&#x2F;h%d&gt;&quot;, n, line.strip(), n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意：实际解析Markdown是带有状态的，即下一行的语义可能与上一行相关。这里我们简化了语法，把每一行视为可以独立转换。</p>
<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><em>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</em></p>
<ul>
<li><p>Cloneable  克隆后为Object对象，需要强转</p>
</li>
<li><p>自己定义 copy()</p>
<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p>
</li>
</ul>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p><em>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</em></p>
<p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p>
<p>因为这个类只有一个实例，因此，自然不能让调用方使用<code>new Xyz()</code>来创建实例了。所以，单例的构造方法必须是<code>private</code>，这样就防止了调用方自己创建实例，但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态字段引用唯一实例:</span><br><span class="line">    private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; private构造方法保证外部无法实例化:</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，外部调用方如何获得这个唯一实例？</p>
<p>答案是提供一个静态方法，直接返回实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态字段引用唯一实例:</span><br><span class="line">    private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过静态方法返回实例:</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; private构造方法保证外部无法实例化:</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接把<code>static</code>变量暴露给外部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态字段引用唯一实例:</span><br><span class="line">    public static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; private构造方法保证外部无法实例化:</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，单例模式的实现方式很简单：</p>
<ol>
<li>只有<code>private</code>构造方法，确保外部无法实例化；</li>
<li>通过<code>private static</code>变量持有唯一实例，保证全局唯一性；</li>
<li>通过<code>public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>
<p>Java标准库有一些类就是单例，例如<code>Runtime</code>这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime &#x3D; Runtime.getRuntime();</span><br></pre></td></tr></table></figure>

<p>另一种实现Singleton的方式是利用Java的<code>enum</code>，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum World &#123;</span><br><span class="line">    &#x2F;&#x2F; 唯一枚举:</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    private String name &#x3D; &quot;world&quot;;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code>World</code>类在调用方看来就可以这么用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; World.INSTANCE.getName();</span><br></pre></td></tr></table></figure>

<p>使用枚举实现Singleton还避免了第一种方式实现Singleton的一个潜在问题：即序列化和反序列化会绕过普通类的<code>private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p>
<p>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component &#x2F;&#x2F; 表示一个单例组件</span><br><span class="line">public class MyService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p>
<p>结构型模式有：</p>
<ul>
<li>适配器</li>
<li>桥接</li>
<li>组合</li>
<li>装饰器</li>
<li>外观</li>
<li>享元</li>
<li>代理</li>
</ul>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319245971489">适配器</a></h3><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？</p>
<p>我们举个例子。如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器：</p>
<p>Adapter模式可以将一个A接口转换为B接口，使得新的对象符合B接口规范。</p>
<p>编写Adapter实际上就是编写一个实现了B接口，并且内部持有A接口的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public BAdapter implements B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public BAdapter(A a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void b() &#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Adapter内部将B接口的调用“转换”为对A接口的调用。</p>
<p>只有A、B接口均为<strong>抽象接口</strong>时，才能非常简单地实现Adapter模式。</p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p><em>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</em></p>
<p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                   ┌───────┐</span><br><span class="line">                   │  Car  │</span><br><span class="line">                   └───────┘</span><br><span class="line">                       ▲</span><br><span class="line">    ┌──────────────────┼───────────────────┐</span><br><span class="line">    │                  │                   │</span><br><span class="line">┌───────┐          ┌───────┐          ┌───────┐</span><br><span class="line">│BigCar │          │TinyCar│          │BossCar│</span><br><span class="line">└───────┘          └───────┘          └───────┘</span><br><span class="line">    ▲                  ▲                  ▲</span><br><span class="line">    │                  │                  │</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │</span><br><span class="line">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│</span><br><span class="line">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │</span><br><span class="line">      └───────────────┘  └───────────────┘  └───────────────┘</span><br></pre></td></tr></table></figure>

<p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p>
<p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p>
<p>我们来看看桥接模式如何解决上述问题。</p>
<p>在桥接模式中，首先把<code>Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。</p>
<p>首先定义抽象类<code>Car</code>，它引用一个<code>Engine</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Car &#123;</span><br><span class="line">    &#x2F;&#x2F; 引用Engine:</span><br><span class="line">    protected Engine engine;</span><br><span class="line"></span><br><span class="line">    public Car(Engine engine) &#123;</span><br><span class="line">        this.engine &#x3D; engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Engine</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Engine &#123;</span><br><span class="line">    void start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着，在一个“修正”的抽象类<code>RefinedCar</code>中定义一些额外操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RefinedCar extends Car &#123;</span><br><span class="line">    public RefinedCar(Engine engine) &#123;</span><br><span class="line">        super(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void drive() &#123;</span><br><span class="line">        this.engine.start();</span><br><span class="line">        System.out.println(&quot;Drive &quot; + getBrand() + &quot; car...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract String getBrand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，最终的不同品牌继承自<code>RefinedCar</code>，例如<code>BossCar</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BossCar extends RefinedCar &#123;</span><br><span class="line">    public BossCar(Engine engine) &#123;</span><br><span class="line">        super(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBrand() &#123;</span><br><span class="line">        return &quot;Boss&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而针对每一种引擎，继承自<code>Engine</code>，例如<code>HybridEngine</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HybridEngine implements Engine &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Start Hybrid Engine...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefinedCar car &#x3D; new BossCar(new HybridEngine());</span><br><span class="line">car.drive();</span><br></pre></td></tr></table></figure>

<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code>Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code>RefinedCar</code>派生一个子类，任何<code>RefinedCar</code>的子类都可以和任何一种<code>Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">       ┌───────────┐</span><br><span class="line">       │    Car    │</span><br><span class="line">       └───────────┘</span><br><span class="line">             ▲</span><br><span class="line">             │</span><br><span class="line">       ┌───────────┐       ┌─────────┐</span><br><span class="line">       │RefinedCar │ ─ ─ ─&gt;│ Engine  │</span><br><span class="line">       └───────────┘       └─────────┘</span><br><span class="line">             ▲                  ▲</span><br><span class="line">    ┌────────┼────────┐         │ ┌──────────────┐</span><br><span class="line">    │        │        │         ├─│  FuelEngine  │</span><br><span class="line">┌───────┐┌───────┐┌───────┐     │ └──────────────┘</span><br><span class="line">│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐</span><br><span class="line">└───────┘└───────┘└───────┘     ├─│ElectricEngine│</span><br><span class="line">                                │ └──────────────┘</span><br><span class="line">                                │ ┌──────────────┐</span><br><span class="line">                                └─│ HybridEngine │</span><br><span class="line">                                  └──────────────┘</span><br></pre></td></tr></table></figure>

<p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p>
<p>我们来看一个具体的例子。在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p>
<p>要以树的结构表示XML，我们可以先抽象出节点类型<code>Node</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加一个节点为子节点:</span><br><span class="line">    Node add(Node node);</span><br><span class="line">    &#x2F;&#x2F; 获取子节点:</span><br><span class="line">    List&lt;Node&gt; children();</span><br><span class="line">    &#x2F;&#x2F; 输出为XML:</span><br><span class="line">    String toXml();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个<code>&lt;abc&gt;</code>这样的节点，我们称之为<code>ElementNode</code>，它可以作为容器包含多个子节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ElementNode implements Node &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;Node&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ElementNode(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node add(Node node) &#123;</span><br><span class="line">        list.add(node);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Node&gt; children() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toXml() &#123;</span><br><span class="line">        String start &#x3D; &quot;&lt;&quot; + name + &quot;&gt;\n&quot;;</span><br><span class="line">        String end &#x3D; &quot;&lt;&#x2F;&quot; + name + &quot;&gt;\n&quot;;</span><br><span class="line">        StringJoiner sj &#x3D; new StringJoiner(&quot;&quot;, start, end);</span><br><span class="line">        list.forEach(node -&gt; &#123;</span><br><span class="line">            sj.add(node.toXml() + &quot;\n&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        return sj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于普通文本，我们把它看作<code>TextNode</code>，它没有子节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TextNode implements Node &#123;</span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    public TextNode(String text) &#123;</span><br><span class="line">        this.text &#x3D; text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node add(Node node) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Node&gt; children() &#123;</span><br><span class="line">        return List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toXml() &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以有注释节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CommentNode implements Node &#123;</span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    public CommentNode(String text) &#123;</span><br><span class="line">        this.text &#x3D; text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node add(Node node) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Node&gt; children() &#123;</span><br><span class="line">        return List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toXml() &#123;</span><br><span class="line">        return &quot;&lt;!-- &quot; + text + &quot; --&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>ElementNode</code>、<code>TextNode</code>和<code>CommentNode</code>，我们就可以构造出一颗树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node root &#x3D; new ElementNode(&quot;school&quot;);</span><br><span class="line">root.add(new ElementNode(&quot;classA&quot;)</span><br><span class="line">        .add(new TextNode(&quot;Tom&quot;))</span><br><span class="line">        .add(new TextNode(&quot;Alice&quot;)));</span><br><span class="line">root.add(new ElementNode(&quot;classB&quot;)</span><br><span class="line">        .add(new TextNode(&quot;Bob&quot;))</span><br><span class="line">        .add(new TextNode(&quot;Grace&quot;))</span><br><span class="line">        .add(new CommentNode(&quot;comment...&quot;)));</span><br><span class="line">System.out.println(root.toXml());</span><br></pre></td></tr></table></figure>

<p>最后通过<code>root</code>节点输出的XML如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;school&gt;</span><br><span class="line">&lt;classA&gt;</span><br><span class="line">Tom</span><br><span class="line">Alice</span><br><span class="line">&lt;&#x2F;classA&gt;</span><br><span class="line">&lt;classB&gt;</span><br><span class="line">Bob</span><br><span class="line">Grace</span><br><span class="line">&lt;!-- comment... --&gt;</span><br><span class="line">&lt;&#x2F;classB&gt;</span><br><span class="line">&lt;&#x2F;school&gt;</span><br></pre></td></tr></table></figure>

<p>可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │   Node    │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼────────────┐</span><br><span class="line">      │            │            │</span><br><span class="line">┌───────────┐┌───────────┐┌───────────┐</span><br><span class="line">│ElementNode││ TextNode  ││CommentNode│</span><br><span class="line">└───────────┘└───────────┘└───────────┘</span><br></pre></td></tr></table></figure>

<p>作为容器节点的<code>ElementNode</code>又可以添加任意个<code>Node</code>，这样就可以构成层级结构。</p>
<p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>

<p>最顶层的Component是接口，对应到IO的就是<code>InputStream</code>这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是<code>FileInputStream</code>、<code>ServletInputStream</code>这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code>FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code>BufferedInputStream</code>、<code>GZIPInputStream</code>等。</p>
<p>Decorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
<p>如果我们要自己设计完整的Decorator模式，应该如何设计？</p>
<p>我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p>
<p>首先，仍然需要定义顶层接口<code>TextNode</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface TextNode &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置text:</span><br><span class="line">    void setText(String text);</span><br><span class="line">    &#x2F;&#x2F; 获取text:</span><br><span class="line">    String getText();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于核心节点，例如<code>&lt;span&gt;</code>，它需要从<code>TextNode</code>直接继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SpanNode implements TextNode &#123;</span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    public void setText(String text) &#123;</span><br><span class="line">        this.text &#x3D; text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getText() &#123;</span><br><span class="line">        return &quot;&lt;span&gt;&quot; + text + &quot;&lt;&#x2F;span&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着，为了实现Decorator模式，需要有一个抽象的Decorator类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class NodeDecorator implements TextNode &#123;</span><br><span class="line">    protected final TextNode target;</span><br><span class="line"></span><br><span class="line">    protected NodeDecorator(TextNode target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setText(String text) &#123;</span><br><span class="line">        this.target.setText(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>NodeDecorator</code>类的核心是持有一个<code>TextNode</code>，即将要把功能附加到的<code>TextNode</code>实例。接下来就可以写一个加粗功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BoldDecorator extends NodeDecorator &#123;</span><br><span class="line">    public BoldDecorator(TextNode target) &#123;</span><br><span class="line">        super(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getText() &#123;</span><br><span class="line">        return &quot;&lt;b&gt;&quot; + target.getText() + &quot;&lt;&#x2F;b&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，可以继续加<code>ItalicDecorator</code>、<code>UnderlineDecorator</code>等。客户端可以自由组合这些Decorator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TextNode n1 &#x3D; new SpanNode();</span><br><span class="line">TextNode n2 &#x3D; new BoldDecorator(new UnderlineDecorator(new SpanNode()));</span><br><span class="line">TextNode n3 &#x3D; new ItalicDecorator(new BoldDecorator(new SpanNode()));</span><br><span class="line">n1.setText(&quot;Hello&quot;);</span><br><span class="line">n2.setText(&quot;Decorated&quot;);</span><br><span class="line">n3.setText(&quot;World&quot;);</span><br><span class="line">System.out.println(n1.getText());</span><br><span class="line">&#x2F;&#x2F; 输出&lt;span&gt;Hello&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(n2.getText());</span><br><span class="line">&#x2F;&#x2F; 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;&#x2F;span&gt;&lt;&#x2F;u&gt;&lt;&#x2F;b&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(n3.getText());</span><br><span class="line">&#x2F;&#x2F; 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;&#x2F;span&gt;&lt;&#x2F;b&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>

<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>一手包办的中间人</p>
<blockquote>
<p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p>
<p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>
<p>我们以注册公司为例，假设注册公司需要三步：</p>
<ol>
<li>向工商局申请公司营业执照；</li>
<li>在银行开设账户；</li>
<li>在税务局开设纳税号。</li>
</ol>
<p>以下是三个系统的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 工商注册:</span><br><span class="line">public class AdminOfIndustry &#123;</span><br><span class="line">    public Company register(String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 银行开户:</span><br><span class="line">public class Bank &#123;</span><br><span class="line">    public String openAccount(String companyId) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 纳税登记:</span><br><span class="line">public class Taxation &#123;</span><br><span class="line">    public String applyTaxCode(String companyId) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    public Company openCompany(String name) &#123;</span><br><span class="line">        Company c &#x3D; this.admin.register(name);</span><br><span class="line">        String bankAccount &#x3D; this.bank.openAccount(c.getId());</span><br><span class="line">        c.setBankAccount(bankAccount);</span><br><span class="line">        String taxCode &#x3D; this.taxation.applyTaxCode(c.getId());</span><br><span class="line">        c.setTaxCode(taxCode);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Company c &#x3D; facade.openCompany(&quot;Facade Software Ltd.&quot;);</span><br></pre></td></tr></table></figure>

<p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p>
<p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p>
<h3 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h3><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>
<p>类似创建<a href="####%E5%8D%95%E4%BE%8B">单例</a></p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><em>为其他对象提供一种代理以控制对这个对象的访问。</em></p>
<p>代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public BAdapter implements B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public BAdapter(A a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void b() &#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AProxy implements A &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public AProxy(A a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void a() &#123;</span><br><span class="line">        this.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？</p>
<p>当然不是。我们观察Proxy的实现A接口的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void a() &#123;</span><br><span class="line">    this.a.a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写当然没啥卵用。但是，如果我们在调用<code>a.a()</code>的前后，加一些额外的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void a() &#123;</span><br><span class="line">    if (getCurrentUser().isRoot()) &#123;</span><br><span class="line">        this.a.a();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new SecurityException(&quot;Forbidden&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。</p>
<p>有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？</p>
<p>因为我们编写代码的原则有：</p>
<ul>
<li>职责清晰：一个类只负责一件事；</li>
<li>易于测试：一次只测一个功能。</li>
</ul>
<p>用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：</p>
<ul>
<li>A接口：只定义接口；</li>
<li>ABusiness类：只实现A接口的业务逻辑；</li>
<li>APermissionProxy类：只实现A接口的权限检查代理。</li>
</ul>
<p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。</p>
<p>实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：</p>
<h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>
<h4 id="虚代理"><a href="#虚代理" class="headerlink" title="虚代理"></a>虚代理</h4><p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>
<h4 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h4><p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>
<h4 id="智能引用"><a href="#智能引用" class="headerlink" title="智能引用"></a>智能引用</h4><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>
<p>我们来看一下如何应用代理模式编写一个JDBC连接池（<code>DataSource</code>）。我们首先来编写一个虚代理，即如果调用者获取到<code>Connection</code>后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataSource lazyDataSource &#x3D; new LazyDataSource(jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line">System.out.println(&quot;get lazy connection...&quot;);</span><br><span class="line">try (Connection conn1 &#x3D; lazyDataSource.getConnection()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 并没有实际打开真正的Connection</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;get lazy connection...&quot;);</span><br><span class="line">try (Connection conn2 &#x3D; lazyDataSource.getConnection()) &#123;</span><br><span class="line">    try (PreparedStatement ps &#x3D; conn2.prepareStatement(&quot;SELECT * FROM students&quot;)) &#123; &#x2F;&#x2F; 打开了真正的Connection</span><br><span class="line">        try (ResultSet rs &#x3D; ps.executeQuery()) &#123;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getString(&quot;name&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来思考如何实现这个<code>LazyConnectionProxy</code>。为了简化代码，我们首先针对<code>Connection</code>接口做一个抽象的代理类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractConnectionProxy implements Connection &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 抽象方法获取实际的Connection:</span><br><span class="line">    protected abstract Connection getRealConnection();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现Connection接口的每一个方法:</span><br><span class="line">    public Statement createStatement() throws SQLException &#123;</span><br><span class="line">        return getRealConnection().createStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PreparedStatement prepareStatement(String sql) throws SQLException &#123;</span><br><span class="line">        return getRealConnection().prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...其他代理方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>AbstractConnectionProxy</code>代理类的作用是把<code>Connection</code>接口定义的方法全部实现一遍，因为<code>Connection</code>接口定义的方法太多了，后面我们要编写的<code>LazyConnectionProxy</code>只需要继承<code>AbstractConnectionProxy</code>，就不必再把<code>Connection</code>接口方法挨个实现一遍。</p>
<p><code>LazyConnectionProxy</code>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class LazyConnectionProxy extends AbstractConnectionProxy &#123;</span><br><span class="line">    private Supplier&lt;Connection&gt; supplier;</span><br><span class="line">    private Connection target &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public LazyConnectionProxy(Supplier&lt;Connection&gt; supplier) &#123;</span><br><span class="line">        this.supplier &#x3D; supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 覆写close方法：只有target不为null时才需要关闭:</span><br><span class="line">    public void close() throws SQLException &#123;</span><br><span class="line">        if (target !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Close connection: &quot; + target);</span><br><span class="line">            super.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Connection getRealConnection() &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; null) &#123;</span><br><span class="line">            target &#x3D; supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用者没有执行任何SQL语句，那么<code>target</code>字段始终为<code>null</code>。只有第一次执行SQL语句时（即调用任何类似<code>prepareStatement()</code>方法时，触发<code>getRealConnection()</code>调用），才会真正打开实际的JDBC Connection。</p>
<p>最后，我们还需要编写一个<code>LazyDataSource</code>来支持这个<code>LazyConnecitonProxy</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class LazyDataSource implements DataSource &#123;</span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public LazyDataSource(String url, String username, String password) &#123;</span><br><span class="line">        this.url &#x3D; url;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Connection getConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">        return new LazyConnectionProxy(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Connection conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class="line">                System.out.println(&quot;Open connection: &quot; + conn);</span><br><span class="line">                return conn;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行代码，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get lazy connection...</span><br><span class="line">get lazy connection...</span><br><span class="line">Open connection: com.mysql.jdbc.JDBC4Connection@7a36aefa</span><br><span class="line">小明</span><br><span class="line">小红</span><br><span class="line">小军</span><br><span class="line">小白</span><br><span class="line">...</span><br><span class="line">Close connection: com.mysql.jdbc.JDBC4Connection@7a36aefa</span><br></pre></td></tr></table></figure>

<p>可见第一个<code>getConnection()</code>调用获取到的<code>LazyConnectionProxy</code>并没有实际打开真正的JDBC Connection。</p>
<p>使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataSource pooledDataSource &#x3D; new PooledDataSource(jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line">try (Connection conn &#x3D; pooledDataSource.getConnection()) &#123;</span><br><span class="line">&#125;</span><br><span class="line">try (Connection conn &#x3D; pooledDataSource.getConnection()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取到的是同一个Connection</span><br><span class="line">&#125;</span><br><span class="line">try (Connection conn &#x3D; pooledDataSource.getConnection()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取到的是同一个Connection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方并不关心是否复用了<code>Connection</code>，但从<code>PooledDataSource</code>获取的<code>Connection</code>确实自带这个优化功能。如何实现可复用<code>Connection</code>的连接池？答案仍然是使用代理模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class PooledConnectionProxy extends AbstractConnectionProxy &#123;</span><br><span class="line">    &#x2F;&#x2F; 实际的Connection:</span><br><span class="line">    Connection target;</span><br><span class="line">    &#x2F;&#x2F; 空闲队列:</span><br><span class="line">    Queue&lt;PooledConnectionProxy&gt; idleQueue;</span><br><span class="line"></span><br><span class="line">    public PooledConnectionProxy(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection target) &#123;</span><br><span class="line">        this.idleQueue &#x3D; idleQueue;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() throws SQLException &#123;</span><br><span class="line">        System.out.println(&quot;Fake close and released to idle queue for future reuse: &quot; + target);</span><br><span class="line">        &#x2F;&#x2F; 并没有调用实际Connection的close()方法,</span><br><span class="line">        &#x2F;&#x2F; 而是把自己放入空闲队列:</span><br><span class="line">        idleQueue.offer(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Connection getRealConnection() &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复用连接的关键在于覆写<code>close()</code>方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。</p>
<p>空闲队列由<code>PooledDataSource</code>负责维护：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class PooledDataSource implements DataSource &#123;</span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 维护一个空闲队列:</span><br><span class="line">    private Queue&lt;PooledConnectionProxy&gt; idleQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(100);</span><br><span class="line"></span><br><span class="line">    public PooledDataSource(String url, String username, String password) &#123;</span><br><span class="line">        this.url &#x3D; url;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Connection getConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先试图获取一个空闲连接:</span><br><span class="line">        PooledConnectionProxy conn &#x3D; idleQueue.poll();</span><br><span class="line">        if (conn &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有空闲连接时，打开一个新连接:</span><br><span class="line">            conn &#x3D; openNewConnection();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Return pooled connection: &quot; + conn.target);</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private PooledConnectionProxy openNewConnection() throws SQLException &#123;</span><br><span class="line">        Connection conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.println(&quot;Open new connection: &quot; + conn);</span><br><span class="line">        return new PooledConnectionProxy(idleQueue, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行调用方代码，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Open new connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close and released to idle queue for future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br></pre></td></tr></table></figure>

<p>除了第一次打开了一个真正的JDBC Connection，后续获取的<code>Connection</code>实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。</p>
<p>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</p>
<p>有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p>
<p>代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。</p>
<p>使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/16/Vue%E4%B8%AD%E5%BC%95%E5%85%A5%E8%A7%86%E9%A2%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/16/Vue%E4%B8%AD%E5%BC%95%E5%85%A5%E8%A7%86%E9%A2%91/" class="post-title-link" itemprop="url">Vue中引入视频</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-16 15:48:44 / 修改时间：15:50:52" itemprop="dateCreated datePublished" datetime="2021-01-16T15:48:44+08:00">2021-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vue中适配的Video.js</p>
<p><a target="_blank" rel="noopener" href="https://github.com/surmon-china/vue-video-player">Github链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.全局引用</span><br><span class="line">import VueVideoPlayer from &#39;vue-video-player&#39;</span><br><span class="line">import &#39;video.js&#x2F;dist&#x2F;video-js.css&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VideoPlayer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.组件内引用</span><br><span class="line">import &#123; videoPlayer &#125; from &#39;vue-video-player&#39;</span><br><span class="line">import &#39;video.js&#x2F;dist&#x2F;video-js.css&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    videoPlayer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html部分</span><br><span class="line"></span><br><span class="line">&lt;video-player  class&#x3D;&quot;video-player vjs-custom-skin&quot;</span><br><span class="line">     ref&#x3D;&quot;videoPlayer&quot;</span><br><span class="line">     :playsinline&#x3D;&quot;true&quot;</span><br><span class="line">     :options&#x3D;&quot;playerOptions&quot;</span><br><span class="line">&gt;&lt;&#x2F;video-player&gt;</span><br><span class="line">data部分</span><br><span class="line"></span><br><span class="line">playerOptions : &#123;</span><br><span class="line">        playbackRates: [0.7, 1.0, 1.5, 2.0], &#x2F;&#x2F;播放速度</span><br><span class="line">        autoplay: false, &#x2F;&#x2F;如果true,浏览器准备好时开始回放。</span><br><span class="line">        muted: false, &#x2F;&#x2F; 默认情况下将会消除任何音频。</span><br><span class="line">        loop: false, &#x2F;&#x2F; 导致视频一结束就重新开始。</span><br><span class="line">        preload: &#39;auto&#39;, &#x2F;&#x2F; 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持）</span><br><span class="line">        language: &#39;zh-CN&#39;,</span><br><span class="line">        aspectRatio: &#39;16:9&#39;, &#x2F;&#x2F; 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;）</span><br><span class="line">        fluid: true, &#x2F;&#x2F; 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。</span><br><span class="line">        sources: [&#123;</span><br><span class="line">          src: &#39;&#x2F;&#x2F;path&#x2F;to&#x2F;video.mp4&#39;,  &#x2F;&#x2F; 路径</span><br><span class="line">          type: &#39;video&#x2F;mp4&#39;  &#x2F;&#x2F; 类型</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          src: &#39;&#x2F;&#x2F;path&#x2F;to&#x2F;video.webm&#39;,</span><br><span class="line">          type: &#39;video&#x2F;webm&#39;</span><br><span class="line">        &#125;],</span><br><span class="line">        poster: &quot;..&#x2F;..&#x2F;static&#x2F;images&#x2F;test.jpg&quot;, &#x2F;&#x2F;你的封面地址</span><br><span class="line">        &#x2F;&#x2F; width: document.documentElement.clientWidth,</span><br><span class="line">        notSupportedMessage: &#39;此视频暂无法播放，请稍后再试&#39;, &#x2F;&#x2F;允许覆盖Video.js无法播放媒体源时显示的默认信息。</span><br><span class="line">        controlBar: &#123;</span><br><span class="line">          timeDivider: true,</span><br><span class="line">          durationDisplay: true,</span><br><span class="line">          remainingTimeDisplay: false,</span><br><span class="line">          fullscreenToggle: true  &#x2F;&#x2F;全屏按钮</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/15/%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">登陆页面开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-15 23:18:03 / 修改时间：23:25:41" itemprop="dateCreated datePublished" datetime="2021-01-15T23:18:03+08:00">2021-01-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>关于前后端结合</li>
</ol>
<p>前后端分离的意思是前后端之间通过 RESTful API 传递 JSON 数据</p>
<p>开发时，前端用前端的服务器，后端用后端的服务器。</p>
<p>前端服务器把前端请求结果从后端服务器拿到前端，称为反向代理。（常用Nginx）</p>
<ol start="2">
<li>前端相关配置</li>
</ol>
<ul>
<li>设置反向代理<br>因为使用了新的模块 axios，所以需要进入到项目文件夹中，执行 npm install –save axios，以安装这个模块。</li>
</ul>
<p>修改 src\main.js 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置反向代理，前端请求默认发送到 http:&#x2F;&#x2F;localhost:8443&#x2F;api</span><br><span class="line">var axios &#x3D; require(&#39;axios&#39;)</span><br><span class="line">axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;localhost:8443&#x2F;api&#39;</span><br><span class="line">&#x2F;&#x2F; 全局注册，之后可在其他组件中通过 this.$axios 发送数据</span><br><span class="line">Vue.prototype.$axios &#x3D; axios</span><br></pre></td></tr></table></figure>

<ul>
<li>跨域支持<br>为了让后端能够访问到前端的资源，需要配置跨域支持。</li>
</ul>
<p>在 config\index.js 中，找到 proxyTable 位置，修改为以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:8443&#39;,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#39;^&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/15/Vue-elementUI%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Vue-elementUI%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">Vue-elementUI安装及应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-15 23:10:59 / 修改时间：23:32:41" itemprop="dateCreated datePublished" datetime="2021-01-15T23:10:59+08:00">2021-01-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>Element 的官方地址为 <a target="_blank" rel="noopener" href="http://element-cn.eleme.io/#/zh-CN">http://element-cn.eleme.io/#/zh-CN</a></p>
<ol>
<li><p>安装<br>在项目文件夹下，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入</p>
</li>
</ol>
<ul>
<li>完整引入<ul>
<li>修改<code>main.js</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br><span class="line"># new Vue中</span><br><span class="line">render: h &#x3D;&gt; h(App)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/12/Vue-js-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/12/Vue-js-%E4%B8%89/" class="post-title-link" itemprop="url">Vue.js(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-12 22:49:01" itemprop="dateCreated datePublished" datetime="2021-01-12T22:49:01+08:00">2021-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-20 16:36:23" itemprop="dateModified" datetime="2021-01-20T16:36:23+08:00">2021-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vue语法</p>
<ol>
<li>插值绑定</li>
</ol>
<ul>
<li>文本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#123;&#123;&#125;&#125;**</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Vue会优先解释DOM节点中的标签，而变量中的仅当作文本处理<br>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;&#39;&lt;span&gt;15&lt;&#x2F;span&gt;&#39;&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;html&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script scoped&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data ()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            html : &#39;&lt;span&gt;15&lt;&#x2F;span&gt;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#39;15&#39;&#125;&#125;</span><br><span class="line">&lt;span&gt;15&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>HTML<br>可以动态渲染DOM节点<br>开发者在使用HTML插值时应秉承以下原则：<ul>
<li>尽量多的使用Vue自身的模板机制，减少对HTML插值的使用</li>
<li>只对可信内容使用HTML插值</li>
<li>绝不相信用户输入的数据</li>
</ul>
</li>
</ul>
<ol start="2">
<li>属性绑定</li>
</ol>
<ul>
<li><p>v-bind<br>DOM节点的属性基本都可以用v-bind绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-bind:class&#x3D;&quot;className&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            className: &#39;tureName&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>*v-bind<strong>也可以省略不写，直接使用 **:</strong></p>
</li>
<li><p>类名和样式绑定<br>类名本质为一个字符串数组，可以有多个。而样式为键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.color-gray&#123;color : gray;&#125;</span><br><span class="line">.size-18&#123;size : 18px;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p :class&#x3D;&quot;class1&quot;&gt;123123&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            class1: &#123; &#x2F;&#x2F;未绑定类名</span><br><span class="line">                &#39;color-gray&#39;: 0,</span><br><span class="line">                &#39;size-18&#39;: &#39;&#39;</span><br><span class="line">                &#x2F;&#x2F; 0 与 &#39;&#39; 均为 false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>针对不同的数据类型采用不同的渲染策略。</p>
</li>
</ul>
<ol start="3">
<li>事件绑定</li>
</ol>
<ul>
<li><p>v-on 简写 <strong>@</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click&#x3D;&quot;demo()&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;demo()&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见修饰符<br>JS常见：<br>event.preventDefault() 阻止节点默认行为<br>event.stopPropagation() 阻止冒泡</p>
</li>
</ul>
<p>DOM中 event 发生时，首先自根部到发生时间的节点，再冒泡回根部，返回给浏览器。</p>
<pre><code>* .stop 阻止冒泡
* .prevent 阻止默认行为
* .capture 阻止事件捕获
* .self 限制事件仅作用于自身节点
* .once 触发一次就接触监听
* .passive 移动端，可用事件（滚动） 限制事件永不调用preventDefault()方法</code></pre>
<ul>
<li>按键修饰符</li>
<li>*&lt;button @keyup.13=”console.log($event)”&gt;</button>**</li>
</ul>
<ul>
<li>组合修饰符<br>&lt;button @click.ctrl=”console.log($event)”&gt;</button></li>
</ul>
<ol start="4">
<li>双向绑定</li>
</ol>
<ul>
<li>v-models</li>
</ul>
<ol start="5">
<li>条件渲染与列表渲染</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/12/Vue-js-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/12/Vue-js-%E4%BA%8C/" class="post-title-link" itemprop="url">Vue.js(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-12 22:22:50 / 修改时间：22:44:41" itemprop="dateCreated datePublished" datetime="2021-01-12T22:22:50+08:00">2021-01-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vue 基本介绍</p>
<ul>
<li>生命周期<ul>
<li>create -&gt; insert data -&gt; 绑定el与模板 -&gt; render -&gt; Mount - - - &gt; destory</li>
</ul>
</li>
<li>数据响应式原理<ul>
<li>数据链<br>修改数据起点时，链路上所有的数据都将被更新</li>
<li>函数式编程<br>核心为<strong>根据元数据生成新的衍生数据，提供唯一的输入，函数将返回唯一确定的输出</strong></li>
<li>Vue中的数据链<br>提供了<strong>computed</strong>这一属性。只能以函数形式声明。（this表示当前vue实例）<br>demo：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    data ()&#123;</span><br><span class="line">        a: 3</span><br><span class="line">    &#125;</span><br><span class="line">    computed:&#123; &#x2F;&#x2F;计算属性</span><br><span class="line">        a()&#123;</span><br><span class="line">            return this.a * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数据绑定视图<br>内涵大致为赋值时使用setter，取值时使用getter，渲染时属性记录为依赖，setter被调用时会通知watcher将后面的依赖项的值更新。所以说这也就是为什么在已经渲染好的网页中，数据刚修改，在浏览器中就可以看到变化的原因。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1b.mk/2021/01/12/Vue-js-%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.ico">
      <meta itemprop="name" content="二茂铁Fe">
      <meta itemprop="description" content="二茂铁Fe的小屋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Bottle of Milk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/12/Vue-js-%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Vue.js(一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-12 15:37:58 / 修改时间：22:22:14" itemprop="dateCreated datePublished" datetime="2021-01-12T15:37:58+08:00">2021-01-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>《Vue.js 从入门到项目实战》</p>
<p>（一） 引言</p>
<ul>
<li><p>发展历史<br>CGI(Common Gateway Interface)<br>动态数据与网页模板结合，送至服务端，服务器返回浏览器网页数据</p>
</li>
<li><p>Ajax</p>
</li>
<li><p>虚拟DOM</p>
</li>
<li><p>从MVC(Model View Controller)到MMVC(Model View Viewmodel)</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="二茂铁Fe"
      src="/images/avatar.ico">
  <p class="site-author-name" itemprop="name">二茂铁Fe</p>
  <div class="site-description" itemprop="description">二茂铁Fe的小屋</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ermaotie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ermaotie" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Meise1015@gmail.com" title="E-Mail → mailto:Meise1015@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/291216757" title="Bilibli → https:&#x2F;&#x2F;space.bilibili.com&#x2F;291216757" rel="noopener" target="_blank"><i class="fas fa-tv fa-fw"></i>Bilibli</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Matrix40676867" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Matrix40676867" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">二茂铁Fe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


</body>
</html>
